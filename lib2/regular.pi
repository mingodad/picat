regular(L, Q, S, M, Q0, Fs), list(L) =>
    W = to_array(L),
    regular_aux(W, Q, S, M, Q0, Fs).
regular(L, Q, S, M, Q0, Fs), array(L) =>
    regular_aux(L, Q, S, M, Q0, Fs).
regular(L, _Q, _S, _M, _Q0, _Fs) =>
    handle_exception($list_or_array_expected(L),regular).
    
regular_aux({}, _Q, _S, _M, Q0, Fs) =>
    element(_,Fs,Q0).
regular_aux(W, Q, S, M, Q0, Fs) =>
    check_regular_args(Q, S, M, Q0, Fs, Matrix, FsLst),
    W :: 1..S,
    N = len(W),
    Visited = new_array(Q,N+1),                        % Visited[I,T] is true if I is visited at time T
    Visited[Q0,1] = 1,                                 % Q0 is the starting state
    foreach (I in 1..Q)
        if I !== Q0 then
            Visited[I,1] = 0                           % there is only one starting state
        end,
        if not membchk(I,FsLst) then
            Visited[I,N+1] = 0
        end
    end,
    preprocess_regular_sat_mip(Q,S,Matrix,Q0,FsLst,Visited,N),
    Visited :: 0..1,
    %
    foreach (T in 2..N)                                % exactly one state is visited at each time
        sum([Visited[I,T] : I in 1..Q]) #= 1
    end,
    sum([Visited[I,N+1] : I in FsLst]) #= 1,           % at time N+1, one of the final states is visited          
    %
    SymbolArr = new_array(Q,Q),                        % SymbolArr[I,J] : possible symbols that can be generated by the transition I -> J
    foreach (I in 1..Q, J in 1..Q)
        Symbs = [],
        foreach (Input in 1..S)
            Entry = Matrix[I,Input],
            if list(Entry) then
                if membchk(J, Entry) then Symbs := [Input|Symbs] end
            else
                if Entry == J then Symbs := [Input|Symbs] end
            end
        end,
        SymbolArr[I,J] = Symbs
    end,
    %
    Neibs = new_array(Q),                              % Neibs[I] : neighboring states that are directly reachable from state I
    foreach (I in 1..Q)
        Neibs[I] = [J : J in 1..Q, SymbolArr[I,J] !== []]
    end,
    %
    ReifMapArr = new_array(N),
    foreach (T in 1..N) ReifMapArr[T] = new_map() end,
    foreach (I in 1..Q, T in 1..N, Visited[I,T] !== 0)          % constrain output symbols
        Visited[I,T] #=> sum([Visited[J,T+1] : J in Neibs[I]]) #>= 1,  % ge (not eq) is ok since only one state is visited at each time
        foreach (J in Neibs[I], Visited[J,T+1] !== 0)
            Symbs = SymbolArr[I,J],
            if ReifMapArr[T].has_key(Symbs) then
                B = ReifMapArr[T].get(Symbs)
            else
                if Symbs = [Symb] then
                    B #<=> (W[T] #= Symb)
                else
                    B #<=> (W[T] :: Symbs)
                end,
                ReifMapArr[T].put(Symbs,B)
            end,
            #~Visited[I,T] #\/ #~Visited[J,T+1] #\/ B           % I -> J is a valid transition
        end
    end.
