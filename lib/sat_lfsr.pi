module sat.
import common_constr.

% '#!='(X,Y) =>  X #!= Y.
% '#/\\'(X,Y) =>  X #/\ Y.
% '#<'(X,Y) =>  X #< Y.
% '#<='(X,Y) =>  X #=< Y.
% '#<=>'(X,Y) =>  X #<=> Y.
% '#='(X,Y) => X #= Y.
% '#=<'(X,Y) =>  X #=< Y.
% '#=>'(X,Y) =>  X #=> Y.
% '#>'(X,Y) =>  X #> Y.
% '#>='(X,Y) =>  X #>= Y.
% '#\\/'(X,Y) =>  X #\/ Y.
% '#^'(X,Y) =>  X #^ Y.
% '#~'(X) =>  #~ X.
%  '::'(Vars,Domain) => '::'(Vars,Domain).
% all_different(FDVars) => all_different(FDVars).
% all_different_except_0(Xs) => all_different_except_0(Xs).
% all_distinct(FDVars) => all_distinct(FDVars).
% assignment(FDVars1,FDVars2) => assignment(FDVars1,FDVars2).
% at_least(N,X,V) => at_least(N,X,V).
% at_most(N,X,V) => at_most(N,X,V).
% circuit(L) => circuit(L).
% count(V,FDVars,Rel,N) => count(V,FDVars,Rel,N).
% cumulative(Starts,Durations,Resources,Limit) => cumulative(Starts,Durations,Resources,Limit).
% decreasing(FDVars) => decreasing(FDVars).
% decreasing_strict(FDVars) => decreasing_strict(FDVars).
% diffn(RectangleList) => diffn(RectangleList).
% disjunctive_tasks(Tasks) => disjunctive_tasks(Tasks).
% element(I,FDVars,V) => element(I,FDVars,V).
% exactly(N, X, V) => exactly(N, X, V).
% fd_disjoint(DVar1,DVar2) => fd_disjoint(DVar1,DVar2).
% fd_dom(FDVar) = fd_dom(FDVar).
% fd_false(FDVar,Elm) => fd_false(FDVar,Elm).
% fd_max(FDVar) = fd_max(FDVar).
% fd_min(FDVar) = fd_min(FDVar).
% fd_min_max(FDVar,Min,Max) => fd_min_max(FDVar,Min,Max).
% fd_next(FDVar,Elm) = fd_next(FDVar,Elm).
% fd_prev(FDVar,Elm) = fd_prev(FDVar,Elm).
% fd_set_false(FDVar,Elm) => fd_set_false(FDVar,Elm).
% fd_size(FDVar) = fd_size(FDVar).
% fd_true(FDVar,Elm) => fd_true(FDVar,Elm).
% fd_vector_min_max(Min,Max) => fd_vector_min_max(Min,Max).
% global_cardinality(FDVars,Pairs) => global_cardinality(FDVars,Pairs).
% increasing(FDVars) => increasing(FDVars).
% increasing_strict(FDVars) => increasing_strict(FDVars).
% lex_le(L1,L2) => lex_le(L1,L2).
% lex_lt(L1,L2) => lex_lt(L1,L2).
% matrix_element(M,I,J,MIJ) => matrix_element(M,I,J,MIJ).
% neqs(Neqs) => neqs(Neqs).
% new_dvar() = new_dvar().
% new_fd_var() = new_fd_var().
% notin(VarOrVars,D) => notin(VarOrVars,D).
% nvalue(N,L) => nvalue(N,L).
% regular(W, Q, S, M, Q0, Fs) => regular(W, Q, S, M, Q0, Fs).
% scalar_product(A, X, Product) => scalar_product(A, X, Product).
% serialized(Starts,Durations) => serialized(Starts,Durations).
% solve(Options,Vars) => solve(Options,Vars)
% solve(Vars) => solve(Vars).
% solve_all(Options,Vars) = solve_all(Options,Vars).
% solve_all(Vars) = solve_all(Vars).
% subcircuit(FDVars) => subcircuit(FDVars).
% subcircuit_grid(A) => subcircuit_grid(A).
% subcircuit_grid(A,K) => subcircuit_grid(A,K).
% subcircuit_grid(A,K,EMap) => subcircuit_grid(A,K,EMap).
% table_in(Vars, Tuples) => table_in(Vars, Tuples).
% table_notin(Vars, Tuples) => table_notin(Vars, Tuples).

'::'(Vars,Domain) =>
    bp.'_$_picat_in'(sat,Vars,Domain).

% '#='(X,Y) => X #= Y.
'#='(X,Y) => bp.'$='(X,Y).

% '#>='(X,Y) =>  X #>= Y.
'#>='(X,Y) => bp.'$>='(X,Y).

% '#>'(X,Y) =>  X #> Y.
'#>'(X,Y) => bp.'$>'(X,Y).

% '#<'(X,Y) =>  X #< Y.
'#<'(X,Y) => bp.'$<'(X,Y).

% '#=<'(X,Y) =>  X #=< Y.
'#=<'(X,Y) => bp.'$=<'(X,Y).

% '#!='(X,Y) =>  X #!= Y.
'#!='(X,Y) => bp.'$\\='(X,Y).

'#\\='(X,Y) => bp.'$\\='(X,Y).

% '#<=>'(X,Y) =>  X #<=> Y.
'#<=>'(X,Y) => bp.'$<=>'(X,Y).

% '#=>'(X,Y) =>  X #=> Y.
'#=>'(X,Y) => 
   bp.'$=>'(X,Y).

% '#/\\'(X,Y) =>  X #/\ Y.
'#/\\'(X,Y) => bp.'$/\\'(X,Y).

% '#\\/'(X,Y) =>  X #\/ Y.
'#\\/'(X,Y) => bp.'$\\/'(X,Y).

% '#^'(X,Y) =>  X #^ Y.
'#^'(X,Y) => bp.'$\\'(X,Y).

% '#~'(X) =>  #~ X.
'#~'(X) => bp.'$\\'(X).

% all_different(FDVars) => all_different(FDVars).
all_different(FDVars) =>
    (array(FDVars) -> to_list(FDVars) = List; List = FDVars),
    bp.'$alldifferent'(List).

% all_distinct(FDVars) => all_distinct(FDVars).
all_distinct(FDVars) =>
    all_different(FDVars).

%
% Requires that all non-zero values in Xs are distinct.
%
alldifferent_except_0(Xs) =>
    all_different_except_0(Xs).

all_different_except_0(Xs) =>
    foreach(I in 1..Xs.length, J in 1..I-1)
        Xs[I] #= 0 #\/ Xs[J] #= 0 #\/ Xs[I] #!= Xs[J]
    end.

% element(I,FDVars,V) => element(I,FDVars,V).
element(I,FDVars,V) =>
    (array(FDVars) -> to_list(FDVars) = List; List = FDVars),
    (bp.dvar_or_int_list(List) -> true; handle_exception($dvar_or_int_list_expected(List), element)),
    bp.'$element'(I,List,V,sat).

% fd_disjoint(DVar1,DVar2) => fd_disjoint(DVar1,DVar2).
fd_disjoint(DVar1,DVar2), dvar_or_int(DVar1), dvar_or_int(DVar2) => bp.b_DM_DISJOINT_cc(DVar1,DVar2).
fd_disjoint(DVar1,DVar2) =>
    Source = fd_disjoint,
    (dvar_or_int(DVar1) -> handle_exception($dvar_expected(DVar2), Source); handle_exception($dvar_expected(DVar1), Source)).

% fd_set_false(FDVar,Elm) => fd_set_false(FDVar,Elm).
fd_set_false(FDVar,Elm), dvar_or_int(FDVar), integer(Elm) => 
    bp.domain_set_false(FDVar,Elm).
fd_set_false(FDVar,Elm) =>
    Source = fd_set_false,
    (integer(Elm) ->
        handle_exception($dvar_expected(FDVar), Source)
    ;
        handle_exception($integer_expected(Elm), Source)
    ).

% count(V,FDVars,Rel,N) => count(V,FDVars,Rel,N).
count(V,FDVars,Rel,N) =>
    (array(FDVars) -> to_list(FDVars) = List; List = FDVars),
    reified_bool_vars(List,V,Bs),
    count_aux(Bs,Rel,N).

reified_bool_vars([],_V,Bs) => Bs = [].
reified_bool_vars([E|List],V,Bs) =>
    Bs = [B|BsR],
    B #<=> (V #= E),
    reified_bool_vars(List,V,BsR).

count_aux(Bs,'#=', N) => sum(Bs) #= N.
count_aux(Bs,'#!=', N) => sum(Bs) #!= N.
count_aux(Bs,'#\\=', N) => sum(Bs) #!= N.
count_aux(Bs,'#>', N) => sum(Bs) #> N.
count_aux(Bs,'#>=', N) => sum(Bs) #>= N.
count_aux(Bs,'#<', N) => sum(Bs) #< N.
count_aux(Bs,'#=<', N) => sum(Bs) #=< N.
count_aux(Bs,'#<=', N) => sum(Bs) #=< N.

count(V,FDVars,N) =>
    count(V,FDVars,'#=',N).

% cumulative(Starts,Durations,Resources,Limit) => cumulative(Starts,Durations,Resources,Limit).
cumulative(Starts,Durations,Resources,Limit) =>
    (array(Starts) -> to_list(Starts) = SList; SList = Starts),    
    (array(Durations) -> to_list(Durations) = DList; DList = Durations),    
    (array(Resources) -> to_list(Resources) = RList; RList = Resources),
%    println($cumu(Starts,Durations,Resources,Limit)),
    bp.bp_cumulative(SList,DList,RList,Limit,sat).
    
% diffn(RectangleList) => diffn(RectangleList).
diffn(RectangleList) =>
    (array(RectangleList) -> to_list(RectangleList) = RList; RList = RectangleList),
    bp.bp_diffn(RList,sat).

% disjunctive_tasks(Tasks) => disjunctive_tasks(Tasks).
disjunctive_tasks(Tasks) =>
    (array(Tasks) -> to_list(Tasks) = TList; TList = Tasks),    
    disjunctive_tasks_aux(TList).

disjunctive_tasks_aux([]) => true.
disjunctive_tasks_aux([disj_tasks(S1,D1,S2,D2)|Tasks]) =>
    S1+D1 #=< S2 #\/ S2+D2 #=< S1,
    disjunctive_tasks_aux(Tasks).
disjunctive_tasks_aux(Tasks) =>
    handle_exception($invalid_tasks(Tasks), disjunctive_tasks).

% assignment(FDVars1,FDVars2) => assignment(FDVars1,FDVars2).
assignment(FDVars1,FDVars2) =>
    bp.picat_preprocess_assignment(FDVars1,FDVars2,Vect1,Vect2,N),
    M1 = new_array(N,N),                         % M1[I,J] = 1 iff FDVars1[I] = J
    M1 :: 0..1,
    M2 = new_array(N,N),                         % M2[I,J] = 1 iff FDVars2[I] = J
    foreach (I in 1..N, J in 1..N)               % M2 is M1's transpose
        M2[I,J] = M1[J,I]
    end,
    foreach (I in 1..N, J in 1..N)               % channel
        M1[I,J] #<=> Vect1[I] #= J,
        M2[I,J] #<=> Vect2[I] #= J
    end,
    foreach (J in 1..N)                         
        sum([M1[I, J] : I in 1..N]) #= 1          % all_different(FDVars1),
    end.


% solve(Vars) => solve(Vars).
solve(Vars) => solve([],Vars).

% solve(Options,Vars) => solve(Options,Vars)
solve(Options,Vars) =>
    (bp.dvar_or_int_list(Vars) ->
        VList = Vars
    ;
        VList = vars(Vars),
        (bp.dvar_or_int_list(VList) ->
            true
        ;
            handle_exception($free_var_not_allowed(Vars), solve)
        )
    ),
    (select($report(Call), Options,Options1) ->
        Options2 = [$report('$dyna_eval_pred'(['$picat_top_level'],Call))|Options1]
    ;
        Options2 = Options
    ),
    (select($dump(File), Options2,Options3) ->
        AtomFile = to_atom(File),
        Options4 = [$dump(AtomFile)|Options3]
    ;         
        Options4 = Options2
    ),        
    bp.sat_solve(Options4,VList).    

solve_all(Vars) = solve_all([],Vars).

solve_all(Options,Vars) =
    findall(Vars, solve(Options,Vars)).

%%%%%%%%%%%%%%%%%%%%%%%% common to cp and sat modules %%%%%%%%%%%%%%%%%%%%%%
% new_fd_var() = new_fd_var().
new_fd_var() = FDVar =>
    bp.fd_new_var(FDVar).

new_dvar() = FDVar =>
    bp.fd_new_var(FDVar).

%%
table_in(Vars,Tuples) =>
    bp.'$table_in'(Vars,Tuples).

%%
notin(Vars,Domain) =>
    bp.'_$_picat_notin'(sat,Vars,Domain).

%%
table_notin(Vars,Tuples) =>
    bp.'$table_notin'(Vars,Tuples).

% fd_dom(FDVar) = fd_dom(FDVar).
fd_dom(FDVar) = List, integer(FDVar) => List = [FDVar].
fd_dom(FDVar) = List, dvar(FDVar) => bp.domain_min_max(FDVar,Min,Max), bp.fd_domain(FDVar,List,Min,Max).
fd_dom(FDVar) = _List => 
    handle_exception($dvar_expected(FDVar), fd_dom).

% fd_false(FDVar,Elm) => fd_false(FDVar,Elm).
fd_false(FDVar,Elm),
    dvar_or_int(FDVar),
    integer(Elm)
 =>
    bp.b_DM_FALSE_cc(FDVar,Elm).
fd_false(FDVar,Elm) =>
    bp.expect_dvar_int(FDVar,Elm,fd_false).

% fd_max(FDVar) = fd_max(FDVar).
fd_max(FDVar) = Max => (dvar_or_int(FDVar) -> bp.domain_min_max(FDVar,_, Max); handle_exception($dvar_expected(FDVar), fd_max)).

% fd_min(FDVar) = fd_min(FDVar).
fd_min(FDVar) = Min => (dvar_or_int(FDVar) -> bp.domain_min_max(FDVar,Min, _); handle_exception($dvar_expected(FDVar), fd_min)).

% fd_min_max(FDVar,Min,Max) => fd_min_max(FDVar,Min,Max).
fd_min_max(FDVar,Min,Max) => 
    (dvar_or_int(FDVar) ->
    bp.domain_min_max(FDVar,Min,Max)
    ;
        handle_exception($dvar_expected(FDVar), fd_min_max)
    ).

% fd_next(FDVar,Elm) = fd_next(FDVar,Elm).
fd_next(FDVar,Elm) = NextElm, 
    dvar(FDVar), integer(Elm) 
 =>
    (bp.domain_next_inst(FDVar,Elm, NextElm) -> true; handle_exception(failed,fd_next)).
fd_next(FDVar,Elm) = _NextElm =>
    bp.expect_dvar_int(FDVar,Elm,fd_next).

% fd_prev(FDVar,Elm) = fd_prev(FDVar,Elm).
fd_prev(FDVar,Elm) = PrevElm,
    dvar(FDVar), integer(Elm) 
 =>
    (bp.b_DM_PREV_ccf(FDVar,Elm, PrevElm) -> true; handle_exception(failed,fd_prev)).
fd_prev(FDVar,Elm) = _PrevElm =>
    bp.expect_dvar_int(FDVar,Elm,fd_prev).

% fd_size(FDVar) = fd_size(FDVar).
fd_size(FDVar) = Size =>
    (dvar(FDVar) -> 
        bp.b_DM_COUNT_cf(FDVar,Size)
    ; integer(FDVar) ->
        Size = 1
    ;
        handle_exception($dvar_expected(FDVar), fd_size)
    ).
    
% fd_true(FDVar,Elm) => fd_true(FDVar,Elm).
fd_true(FDVar,Elm),
    dvar_or_int(FDVar),
    integer(Elm)
 =>
    bp.b_DM_TRUE_cc(FDVar,Elm).
fd_true(FDVar,Elm) =>
    bp.expect_dvar_int(FDVar,Elm,fd_true).

fd_vector_min_max(Min,Max) =>
    bp.fd_vector_min_max(Min,Max).

/************************************************************************* 
circuit(L): L is a list of variables X1,X2,...,Xn. An assignment
{X1->a1,X2->a2,...,Xn->an} satisfies this constraint if it forms a Hamilton cycle. 
To be more specific, each variable has a different value and no sub-cycles can be 
formed.  For example, for the constraint circult([X1,X2,X3,X4]), 
[3,4,2,1] is a solution, but [2,1,4,3] is not because it contains sub-cycles.
*************************************************************************/
circuit(L), list(L) =>
    A = to_array(L),
    circuit_aux(A).
circuit(A), array(A) =>
    circuit_aux(A).
circuit(L) =>
    handle_exception($array_or_list_expected(L), circuit).

circuit_aux({V}) => V = 1.
circuit_aux(A) =>                             % single-agent path finding
    N = length(A),
    A :: 1..N,
    foreach (I in 1..N)                       % not reflexive
        bp.domain_set_false(A[I],I)
    end,
    circuit_init_adj_matrix(H,A,N,NeibVect,TNeibVect),
    
    H :: 0..1,
    foreach (I in 1..N, J in 1..N, I !== J)   % channel
        if H[I,J] !== 0 then
            H[I, J] #<=> (A[I] #= J),
            if N > 2 then
                #~H[I,J] #\/ #~H[J,I]
            end
        end
    end,
    foreach (I in 1..N)                       
        sum([H[J,I] : J in 1..N]) #= 1         % each node has exactly one incoming edge
    end,

    circuit_choose_start(A,1, fd_size(A[1]), Start,1,N),
     % ban sub-cycles
    P = new_array(N),                          % P[I] is node I's position
    P[Start] = 1,
    P :: 1..N,
    circuit_preprocess(N,P,Start,NeibVect,TNeibVect),
     %
    foreach (I in 1..N, I !== Start)
        H[Start,I] #=> P[I] #= 2,         % H[Start,I] -> I is the successor of Start
        H[I, Start] #=> (P[I] #= N)        % H[I,Start] -> I is visited at time N
    end,
     % if edge (I,J) is in, then J's position is the successor of I's position
    foreach (I in 1..N, I !== Start, J in 1..N, J !== Start, H[I,J] !== 0)
        H[I,J] #=> P[J] #= P[I]+1
    end.

% H is the adjacent matrix representation of a Hamilton cycle in graph A
% set H[I,J] = 0 if (I,J) is not an edge in graph A
circuit_init_adj_matrix(H,A,N,NeibVect,TNeibVect) =>
    H = new_array(N,N),                         % H[I,J] = 1 iff (I,J) an edge in the Hamilton cycle
    NeibVect = new_array(N),                    % adjacency list
    TNeibVect = new_array(N),                   % adjacency list of the transpose graph
    foreach (I in 1..N, J in 1..N)              % H is a subgraph of A
        if fd_true(A[I],J) then
            true
        else
            H[I,J] = 0
        end
    end,
    foreach (I in 1..N)
        NeibVect[I] = [J : J in 1..N, H[I,J] !== 0],
        TNeibVect[I] = [J : J in 1..N, H[J,I] !== 0]
    end.

% choose a node that has the smallest out-degree to start with
circuit_choose_start(_A,CurIndex,_CurDeg,BestIndex,I,N), I > N => BestIndex = CurIndex.
circuit_choose_start(A,CurIndex,CurDeg,BestIndex,I,N) =>
    X = A[I],
    Deg = fd_size(X),
    (Deg < CurDeg ->
        CurIndex1 = I,
        CurDeg1 = Deg
    ;
        CurIndex1 = CurIndex,
        CurDeg1 = CurDeg
    ),
    circuit_choose_start(A,CurIndex1,CurDeg1,BestIndex,I+1,N).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Shortest-distance heuristic: For a node, let D0 be the shortest distance to
% it from Start. Then the node cannot be reached at times 1,..., D0, because
% Start is visited at time 1. Likewise, let D1 be the shortest distance from
% the node to Start. Then the node cannot be visited at times (N-D1+2)..N.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
circuit_preprocess(N,P,Start,NeibVect,TNeibVect) =>
    (NeibVect == TNeibVect -> Undirected = 1; Undirected = 0),
    circuit_reason_forward(Start,[Start],1,NeibVect,P,1,N,Done),
    circuit_reason_backward(Start,[Start],1,TNeibVect,P,N+1,N,Undirected,Done),
    if Done == 0 then     % some frontiers are too large to expand, so use the shortest-distance heuristic
        circuit_shortest_distance0(Start,N,NeibVect,SDFromStart),
        circuit_shortest_distance0(Start,N,TNeibVect,SDToStart),
        foreach (I in 1..N, I !== Start)
            foreach (T in 1..SDFromStart[I])
                bp.domain_set_false(P[I], T)
            end,
            foreach (T in (N-SDToStart[I]+2)..N)
                bp.domain_set_false(P[I], T)
            end
        end
    end.
    
circuit_shortest_distance0(Start,N,NeibVect,DistVect) =>
    DistVect = new_array(N),                                % DistVect[I], the shortest distance from Start to node I
    foreach (I in 1..N)
        DistVect[I] = N
    end,      
    DistVect[Start] := 0,
    MinHeap1 = new_min_heap([[0|Start]]),
    circuit_shortest_distance(MinHeap1,N,NeibVect,DistVect).

% Dijkstra's algorithm
circuit_shortest_distance(MinHeap,_N,_NeibVect,_DistVect), heap_is_empty(MinHeap) => true.
circuit_shortest_distance(MinHeap,N,NeibVect,DistVect) =>
    [Dist|Node] = heap_pop(MinHeap),
    Dist1 = Dist+1,
    foreach (Neib in NeibVect[Node])
        if (DistVect[Neib] =< Dist1) then
            true
        else
            heap_push(MinHeap,[Dist1|Neib]),
            DistVect[Neib] := Dist1
        end
    end,
    circuit_shortest_distance(MinHeap,N,NeibVect,DistVect).

%% When expanding forward, the first frontier is [Start] at time 1. After expanding Front, Font1 becomes the new frontier.
%% Assume the agent is in a state in Front at time T. Then, it will be in a state in Front1 at time T+1.
circuit_reason_forward(Start,Front,FrontSize,NeibVect,P,T,N,Done) =>
    (T == N ->
        true
    ; FrontSize =< 512, FrontSize < N-1 ->
        T1 is T+1,
        circuit_expand(Start,NeibVect,Front,Front1),
        circuit_exclude_unreachable(1,N,Front1,P,T1),
        circuit_reason_forward(Start,Front1, len(Front1), NeibVect,P,T1,N,Done)
    ; 
        Done = 0
    ).

%% When expanding backward, the first frontier is [Start] at time N+1
circuit_reason_backward(Start,Front,FrontSize,TNeibVect,P,T,N,Undirected,Done) =>
    (T == 2 ->
        true
    ; FrontSize =< 512, FrontSize < N-1 ->
        T1 is T-1,
        circuit_expand(Start,TNeibVect,Front,Front1),
        circuit_exclude_unreachable(1,N,Front1,P,T1),
        FrontSize1 = len(Front1),        
        if FrontSize1 == 2 && Undirected == 1 then     % the distance to Start is N-T1+1
            Front1 = [X1,X2],                          % visit one at time N-T1+2 and visit the other at time T1
            foreach (TT in N-T1+3..T1-1)
                bp.domain_set_false(P[X1],TT),
                bp.domain_set_false(P[X2],TT)
            end
        end,
        circuit_reason_backward(Start,Front1,FrontSize1,TNeibVect,P,T1,N,Undirected,Done)
    ;
        Done = 0
    ).

% Expand Front to yield the next frontier Front1.
circuit_expand(Start,NeibVect,Front,Front1) =>
    TmpFront = [J : I in Front, J in NeibVect[I], J !== Start],
    Front1 = sort_remove_dups(TmpFront).

% for each E in 1..Max that is not included in Dom, E cannot be mapped to position Pos
circuit_exclude_unreachable(E,Max,_Dom,_P,_Pos), E > Max => true.
circuit_exclude_unreachable(E,Max,[E|Dom],P,Pos) =>
    circuit_exclude_unreachable(E+1,Max,Dom,P,Pos).
circuit_exclude_unreachable(E,Max,[Ed|Dom],P,Pos), E > Ed =>
    circuit_exclude_unreachable(E,Max,Dom,P,Pos).
circuit_exclude_unreachable(E,Max,Dom,P,Pos) =>
    bp.domain_set_false(P[E],Pos),
    circuit_exclude_unreachable(E+1,Max,Dom,P,Pos).

/************************************************************************* 
subcircuit(L):  L is a list or an array of variables X1,X2,...,Xn.
L forms a subcircuit where Xi = j (j \= i) means that j is the successor of i 
and Xi = i means that i is not in the circuit. No sub-cycles are allowed.
*************************************************************************/
subcircuit(L), list(L) =>
    subcircuit_aux(L.to_array()).
subcircuit(A), array(A) =>
    subcircuit_aux(A).
subcircuit(L) =>
    handle_exception($array_or_list_expected(L), subcircuit).

subcircuit_aux(A), subcircuit_no_loop(A) =>
    circuit_aux(A).
subcircuit_aux({V}) => V = 1.
subcircuit_aux(A) =>
    A.length = N,
    A :: 1..N,
    H = new_array(N,N),                          % H[I,I] = 1 means node I is not in the circuit
    subcircuit_init_adj_matrix(H,A,N,MinK,MaxK),
    H :: 0..1,
    K :: MinK..MaxK,                             % number of vertices in the cycle
    foreach (I in 1..N, J in 1..N)               % channel
        if H[I,J] !== 0 then
            H[I, J] #<=> (A[I] #= J)
        end
    end,
    foreach (I in 1..N)                          % each node has exactly one incoming edge
        sum([H[J,I] : J in 1..N]) #= 1        
    end,
    K #= sum([ #~H[I,I] : I in 1..N]),
    (MinK > 2 ->
        KGt2 = 1,
        KGt1 = 1
    ;
        KGt2 #<=> (K #> 2),
        KGt1 #<=> (K #> 1),
        KGt2 #=> KGt1
    ),
     % ban sub-cycles
    subcircuit_choose_start(H,N,KGt1,MinK,Start),     % Start[I] = 1 iff the cycle starts at vertex I
    P = new_array(N),                            % each in-cycle vertex is mapped to a unique position
    NB is round(log(2,N)+0.5),                   % number of bits needed by log encoding
    Max is 2**NB-1,
    P :: 0..Max,
    foreach (I in 1..N)
        if H[I,I] == 1 then
            P[I] = 0
        else
            bp.sat_encode_dvar(P[I],_),           % get the log encoding
            H[I,I] #<=> P[I] #= 0
        end
    end,
    foreach (I in 1..N)
        Start[I] #=> P[I] #= 1,
        foreach (J in 1..N, I !== J, H[I,J] !== 0)
            H[I,J] #=> #~H[J,J],
            H[I,J] #=> #~H[I,I],
            if I < J then
                #~KGt2 #\/ #~H[I,J] #\/ #~H[J,I]    % no cycle of size 2
            end,
            entail_lfsr_succ(NB, #~Start[J], H[I,J], P[I], P[J])
        end
    end.

subcircuit_no_loop(A) =>
    N = len(A),
    foreach (I in 1..N)
        fd_false(A[I],I)
    end.

subcircuit_init_adj_matrix(H,A,N,MinK,MaxK) =>
    MinK0 = 0,
    MaxK0 = N,
    foreach (I in 1..N)
        (fd_false(A[I], I) -> MinK0 := MinK0+1; true),
        (A[I] == I -> MaxK0 := MaxK0-1; true),
        foreach (J in 1..N)                    % H is a subgraph of A
            if fd_true(A[I],J) then
                true
            else
                H[I,J] = 0
            end
        end
    end,
    MinK = MinK0,
    MaxK = MaxK0.

%
% Start and HasStarted must follow the following pattern:
%      Start = 0 ... 0 1 0 ... 0
% HasStarted = 0 ... 0 1 1 ... 1
%
subcircuit_choose_start(H,N,KGt1,MinK,Start) =>
    Start = new_array(N),                    % Start[I] = 1 iff the cycle starts at vertex I
    Start :: 0..1,                          
    foreach (I in 1..N)
        H[I,I]  #=> #~Start[I]               % I is not in the cycle
    end,
    HasStarted = new_array(N),               % HasStarted[I] iff there exists I1 (I1 =< I) such that Start[I1]
    HasStarted :: 0..1,
    (MinK > 1 ->
        HasStarted[N-MinK+1] #= 1
    ;
        KGt1 #=> HasStarted[N]
    ),
    #~H[1,1] #=> Start[1],
    HasStarted[1] #<=> Start[1],
    foreach (I in 2..N)
        HasStarted[I-1] #=> HasStarted[I],
        Start[I] #=> #~HasStarted[I-1],
        Start[I] #=> HasStarted[I],
        H[I,I] #\/ HasStarted[I-1] #\/ Start[I],                % (#~H[I,I] #/\ #~HasStarted[I-1]) #=> Start[I],
        #~HasStarted[I] #\/ Start[I] #\/ HasStarted[I-1]        % (HasStarted[I] #/\ #~Start[I]) #=> HasStarted[I-1]
    end.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% A is a two-dimensional array. All the non-zero cells of A form a Hamiltonian cycle
% A[R,C] is filled with 0 if it's known to be not in the cycle.
% The total number of non-zero cells is K
%
subcircuit_grid(A) =>
    hcp_grid(A,_,_).

subcircuit_grid(A,K) =>
    hcp_grid(A,_,K).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
hcp_grid(G) =>
    grid_check_matrix(G,hcp_grid,NRows,NCols),
    Vs = [{(R,C), G[R,C]} : R in 1..NRows, C in 1..NCols],
    Es = [{(R,C), (R1,C1), _} : R in 1..NRows, C in 1..NCols, grid_neibs(G,NRows,NCols,R,C,Neibs), (R1,C1) in Neibs],
    hcp(Vs,Es,_K).

hcp_grid(G,Es) =>
    grid_check_matrix(G,hcp_grid,NRows,NCols),
    Vs = [{(R,C), G[R,C]} : R in 1..NRows, C in 1..NCols],    
    (var(Es) ->
        Es = [{(R,C), (R1,C1), _} : R in 1..NRows, C in 1..NCols, grid_neibs(G,NRows,NCols,R,C,Neibs), (R1,C1) in Neibs]
    ;    
        hcp_grid_check_es(NRows,NCols,Es,hcp_grid)
    ),
    hcp(Vs,Es,_K).

hcp_grid(G,Es,K) =>
    grid_check_matrix(G,hcp_grid,NRows,NCols),
    Vs = [{(R,C), G[R,C]} : R in 1..NRows, C in 1..NCols],
    (var(Es) ->
        Es = [{(R,C), (R1,C1), _} : R in 1..NRows, C in 1..NCols, grid_neibs(G,NRows,NCols,R,C,Neibs), (R1,C1) in Neibs]
    ;    
        hcp_grid_check_es(NRows,NCols,Es,hcp_grid)
    ),
    hcp(Vs,Es,K).

hcp(Vs,Es) =>
    hcp(Vs,Es,_).

hcp(Vs,Es,K) =>
    VNumMap = new_map(),
    hcp_scc_check_vs(Vs,1,N,VNumMap,Bs,0,NZeros,0,MinK,hcp),
    AdjMap = new_map(),
    hcp_check_es(N,Es,VNumMap,AdjMap,hcp),
    hcp_aux(Bs,Es,N,K,VNumMap,AdjMap,NZeros,MinK).

hcp_scc_check_vs([],I,N,_VNumMap,Bs,CountZeros0,CountZeros,CountOnes0,CountOnes,_Source) =>
    N = I-1,
    Bs = [],
    CountZeros = CountZeros0,
    CountOnes = CountOnes0.
hcp_scc_check_vs([{V,B}|Vs],I,N,VNumMap,Bs,CountZeros0,CountZeros,CountOnes0,CountOnes,Source) =>
    hcp_scc_check_vertex(V,Source),
    hcp_scc_check_b(B,Source),
    (B == 0 ->
        CountZeros1 = CountZeros0+1,
        CountOnes1 = CountOnes0
    ; B == 1 ->
        CountZeros1 = CountZeros0,
        CountOnes1 = CountOnes0+1
    ;
        CountZeros1 = CountZeros0,
        CountOnes1 = CountOnes0
    ),
    (VNumMap.has_key(V) ->
        handle_exception($duplicated_vertex_name(V), Source)
    ;
        VNumMap.put(V,I)
    ),
    I1 is I+1,
    Bs = [B|Bs1],
    hcp_scc_check_vs(Vs,I1,N,VNumMap,Bs1,CountZeros1,CountZeros,CountOnes1,CountOnes,Source).
hcp_scc_check_vs([VB|_Vs],_I,_N,_VNumMap,_Bs,_CountZeros0,_CountZeros,_CountOnes0,_CountOnes,Source) =>
    handle_exception($invalid_pair(VB), Source).
hcp_scc_check_vs(Vs,_I,_N,_VNumMap,_Bs,_CountZeros0,_CountZeros,_CountOnes0,_CountOnes,Source) =>
    handle_exception($list_expected(Vs), Source).

hcp_scc_check_vertex(V,_Source), ground(V) => true.
hcp_scc_check_vertex(V,Source) =>
    handle_exception($ground_expected(V), Source).

hcp_scc_check_b(B,_Source), var(B) => bp.domain(B,0,1).
hcp_scc_check_b(0,_Source) => true.
hcp_scc_check_b(1,_Source) => true.
hcp_scc_check_b(B,Source) =>
    handle_exception($dvar_expected(B), Source).

hcp_check_es(N,[],_VNumMap,AdjMap,_Source) =>
    foreach (I in 1..N)
        Neibs = AdjMap.get(I,[]),
        Neibs1 = sort_remove_dups(Neibs),
        AdjMap.put(I,Neibs1)
    end.
hcp_check_es(N,[{V1,V2,B}|Es],VNumMap,AdjMap,Source) =>
    hcp_scc_check_vertex(V1,Source),
    hcp_scc_check_vertex(V2,Source),
    I1 = VNumMap.get(V1,0),
    (I1 == 0 -> handle_exception($unknown_vertex_name(V1), Source); true),
    I2 = VNumMap.get(V2,0),
    (I2 == 0 -> handle_exception($unknown_vertex_name(V2), Source); true),
    Neibs1 = AdjMap.get(I1,[]),
    AdjMap.put(I1,[I2|Neibs1]),
    hcp_scc_check_b(B,Source),
    hcp_check_es(N,Es,VNumMap,AdjMap,Source).
hcp_check_es(_N,[E|_Es],_VNumMap,_AdjMap,Source) =>
    handle_exception($invalid_triplet(E), Source).
hcp_check_es(_N,Es,_VNumMap,_AdjMap,Source) =>
    handle_exception($list_expected(Es), Source).

hcp_grid_check_es(_NRows,_NCols,[],_Source) => true.
hcp_grid_check_es(NRows,NCols, [{(R1,C1), (R2,C2), _B}|Es],Source) =>
    (R1 >= 1, R1 <= NRows, C1 >= 1, C1 <= NCols ->
        true
    ;
        handle_exception($invalid_grid_coordinate(R1,C1), Source)
    ),
    (R2 >= 1, R2 <= NRows, C2 >= 1, C2 <= NCols ->
        true
    ;
        handle_exception($invalid_grid_coordinate(R2,C2), Source)
    ),
    hcp_grid_check_es(NRows,NCols,Es,Source).
hcp_grid_check_es(_NRows,_NCols,[E|_Es],Source) =>
    handle_exception($invalid_triplet(E), Source).
hcp_grid_check_es(_NRows,_NCols,Es,Source) =>
    handle_exception($list_expected(Es), Source). 

hcp_aux(_Bs,Es,N,K,VNumMap,AdjMap,_NZeros,MinK), MinK == N =>    % all vertices are in, convert this to circuit
    K = N,
    A = new_array(N),
    A :: 1..N,
    foreach (I in 1..N)
        Neibs = AdjMap.get(I),
        A[I] :: Neibs
    end,
    foreach ({V1,V2,B} in Es)
        I1 = VNumMap.get(V1),
        I2 = VNumMap.get(V2),
        A[I1] #= I2 #<=> B
    end,
    circuit(A).
hcp_aux(Bs,Es,N,K,VNumMap,AdjMap,NZeros,MinK) =>
    A = to_array(Bs),
    MaxK = max(N-NZeros,1),
    K :: MinK..MaxK,
    sum(Bs) #= K,
    (MinK > 2 ->
        KGt2 = 1,
        KGt1 = 1
    ;
        KGt2 #<=> (K #> 2),
        KGt1 #<=> (K #> 1),
        KGt2 #=> KGt1
    ),
    H = new_array(N,N),                              % H[I,J] = 1 iff edge (I,J) is in the cycle
    foreach ({V1,V2,B} in Es)
        I1 = VNumMap.get(V1),
        I2 = VNumMap.get(V2),
        H[I1,I2] = B,
        (I1 != I2 ->
            B #=> A[I1],
            B #=> A[I2]
        ;
            true
        )
    end,
    foreach (I in 1..N, J in 1..N)
        Cell = H[I,J], 
        if var(Cell) && not dvar(Cell) then
            Cell = 0
        end
    end,
    foreach (I in 1..N)                              % each vertex has exactly one incoming and one outgoing edge
        TmpB #\/ #~A[I] #\/ #~KGt1,                 
        TmpB #=> sum([H[I,J] : J in 1..N, J !== I]) #= 1,
        TmpB #=> sum([H[J,I] : J in 1..N, J !== I]) #= 1        
    end,
     % ban sub-cycles
    hcp_scc_choose_start(A,N,KGt1,MinK,Start),      % Start[I] = 1 iff the cycle starts at vertex I
    DistA = new_array(N),                           % each in-cycle vertex has a unique distance from the start
    NB is round(log(2,N)+0.5),                      % number of bits needed by log encoding
    MaxDist is 2**NB-1,
    DistA :: 0..MaxDist,
	foreach (I in 1..N)
        bp.sat_encode_dvar(DistA[I],_)             % get the log encoding
	end,
    foreach (I in 1..N)
        Start[I] #=> DistA[I] #= 1,
        Neibs = AdjMap.get(I,[]),
        foreach (J in Neibs, H[I,J] !== 0)
            if I < J then
                #~KGt2 #\/ #~H[I,J] #\/ #~H[J,I]    % no cycle of size 2
            end,
            entail_lfsr_succ(NB, #~Start[J], H[I,J], DistA[I], DistA[J])
        end
    end.

%
% Start and HasStarted must follow the following pattern:
%      Start = 0 ... 0 1 0 ... 0
% HasStarted = 0 ... 0 1 1 ... 1
%
hcp_scc_choose_start(_A,N,_KGt1,MinK,Start), N > 1, N == MinK =>   % all the vertices are in
    Start = new_array(N),
    MidIndex is N div 2,
    Start[MidIndex] = 1,
    foreach (I in 1..N, I !== MidIndex)
        Start[I] = 0
    end.
hcp_scc_choose_start(A,N,KGt1,MinK,Start) =>
    Start = new_array(N),                    % Start[I] = 1 iff the cycle starts at vertex I
    Start :: 0..1,                          
    foreach (I in 1..N)
        #~A[I]  #=> #~Start[I]               % I is not in the cycle
    end,
    HasStarted = new_array(N),               % HasStarted[I] iff there exists I1 (I1 =< I) such that Start[I1]
    HasStarted :: 0..1,
    (MinK > 1 ->
        HasStarted[N-MinK+1] #= 1
    ;
        KGt1 #=> HasStarted[N]
    ),
    A[1] #=> Start[1],
    HasStarted[1] #<=> Start[1],
    foreach (I in 2..N)
        HasStarted[I-1] #=> HasStarted[I],
        Start[I] #=> #~HasStarted[I-1],
        Start[I] #=> HasStarted[I],
        #~A[I] #\/ HasStarted[I-1] #\/ Start[I],                % (A[I] #/\ #~HasStarted[I-1]) #=> Start[I],
        #~HasStarted[I] #\/ Start[I] #\/ HasStarted[I-1]        % (HasStarted[I] #/\ #~Start[I]) #=> HasStarted[I-1]
    end.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
scc_grid(G) =>
    scc_grid(G,_K).

scc_grid(G,K) =>
    grid_check_matrix(G,scc_grid,NRows,NCols),
    Vs = [{(R,C), G[R,C]} : R in 1..NRows, C in 1..NCols],
    Es = [{Pos,Pos1,_} : R in 1..NRows, C in 1..NCols,
                         Pos = (R,C),
                         grid_neibs(G,NRows,NCols,R,C,Neibs),
                         Pos1 in Neibs,
                         Pos @=< Pos1],
    scc(Vs,Es,K).

scc(Vs,Es) =>
    scc(Vs,Es,_).

scc(Vs,Es,K) =>
    VNumMap = new_map(),
    hcp_scc_check_vs(Vs,1,N,VNumMap,Bs,0,NZeros,0,MinK,scc),
    AdjMap = new_map(),
    A = to_array(Bs),
    sum(Bs) #= K,
    scc_check_es(A,N,Es,VNumMap,AdjMap,scc),
    scc_aux(A,N,K,AdjMap,NZeros,MinK).

scc_check_es(_A,_N,[],_VNumMap,_AdjMap,_Source) => true.
scc_check_es(A,N,[{V1,V2,B}|Es],VNumMap,AdjMap,Source) =>
    hcp_scc_check_vertex(V1,Source),
    hcp_scc_check_vertex(V2,Source),
    hcp_scc_check_b(B,Source),
    I1 = VNumMap.get(V1,0),
    (I1 == 0 -> handle_exception($unknown_vertex_name(V1), Source); true),
    I2 = VNumMap.get(V2,0),
    (I2 == 0 -> handle_exception($unknown_vertex_name(V2), Source); true),
    Neibs1 = AdjMap.get(I1,[]),
    bp.domain(P21,0,1),    % I2 is I1's parent
    AdjMap.put(I1, [{I2,B,P21}|Neibs1]),
    Neibs2 = AdjMap.get(I2,[]),
    bp.domain(P12,0,1),    % I1 is I2's parent
    AdjMap.put(I2, [{I1,B,P12}|Neibs2]),
    #~P12 #\/ #~P21,                                   % parent is a one-way relation
    #~P12 #\/ B,
    #~P21 #\/ B,                                       % if I1 and I2 are parent-child, then the edge must be in
    (I1 < I2 -> #~B #\/ A[I1], #~B #\/ A[I2]; true),   % if the edge (V1,V2) is in, then both V1 and V2 are in
    scc_check_es(A,N,Es,VNumMap,AdjMap,Source).
scc_check_es(_A,_N,[E|_Es],_VNumMap,_AdjMap,Source) =>
    handle_exception($invalid_triplet(E), Source).
scc_check_es(_A,_N,Es,_VNumMap,_AdjMap,Source) =>
    handle_exception($list_expected(Es), Source).

scc_aux(A,N,K,AdjMap,NZeros,MinK) =>
    MaxK = max(N-NZeros,1),
    K :: MinK..MaxK,
    (MinK > 1 ->
        KGt1 = 1
    ;
        KGt1 #<=> (K #> 1)
    ),
    hcp_scc_choose_start(A,N,KGt1,MinK,Start),     % Start[I] = 1 iff vertex I is the root of the tree
    DistA = new_array(N),
    NB is round(log(2,N)+0.5),                     % number of bits needed by log encoding
    MaxDist is 2**NB-1,
    DistA :: 0..MaxDist,
	foreach (I in 1..N)
        bp.sat_encode_dvar(DistA[I],_)             % get the log encoding
	end,
    foreach (I in 1..N)
        if A[I] == 0 then
            DistA[I] = 0
        else
            #~A[I] #=> DistA[I] #= 0,
            Neibs = AdjMap.get(I,[]),
            if Start[I] == 1 then                   % I has been set to be the root
                DistA[I] = 1,
                foreach ({J,B,P} in Neibs)
                    entail_lfsr_succ(NB, B, 1, 1, DistA[J]),  % B => DistA[J] = succ(1)
                    P = 0                           % J cannot be the parent of I
                end
            else
                Start[I] #=> DistA[I] #= 1,
                Start[I] #=> sum([P : {_,_,P} in Neibs]) #= 0,
                #~Start[I] #/\ A[I] #=> sum([P : {_,_,P} in Neibs]) #= 1,
                foreach ({J,_B,P} in Neibs)
                    entail_lfsr_succ(NB, P, 1, DistA[J], DistA[I])
                end
            end
        end
    end.

grid_check_matrix(A,Source,NRows,NCols) =>
    (array(A) -> true; handle_exception($array_expected(A), Source)),
    NRows = len(A),
    foreach (R in 1..NRows)
        (array(A[R]) -> true; handle_exception($array_expected(A[R]), Source))
    end,
    NCols = len(A[1]).

grid_neibs(A,NRows,NCols,R,C,Neibs) =>
        Neibs = [(R1, C1) : (R1, C1) in [(R-1,C), (R+1,C), (R,C-1), (R,C+1)],
                            R1 >= 1, R1 =< NRows, C1 >= 1, C1 =< NCols, A[R1,C1] !== 0].

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% if B, then Y is the successor of X
entail_lfsr_succ(NB,B1,B2,X,Y) =>
    (var(X) ->
        get_attr(X,'$bool_vars') = $log(_,VectX)
    ;
        VectX = new_array(NB),
        dec_to_bin(X,1,NB,VectX)
    ),
    (var(Y) ->
        get_attr(Y,'$bool_vars') = $log(_,VectY)
    ;
        VectY = new_array(NB),
        dec_to_bin(Y,1,NB,VectY)
    ),
    entail_lfsr_succ_aux(B1,B2,VectX,VectY).

dec_to_bin(_Val,I,NB,_Vect), I > NB => true.
dec_to_bin(Val,I,NB,Vect) =>
   Vect[I] = Val mod 2,
   dec_to_bin(Val div 2, I+1, NB, Vect).

bin_to_dec(_Vect,I,Res0,Res), I == 0 => Res = Res0.
bin_to_dec(Vect,I,Res0,Res) =>
    bin_to_dec(Vect, I-1, 2*Res0+Vect[I], Res).

% B -> Y = succ(X)
entail_lfsr_succ_aux(B1,B2,{X1,X2},Y) =>    % taps = {1,2}
    Y = {Y1,Y2},
    entail_equiv(B1,B2,Y2,X1),
    entail_xor(B1,B2,Y1,X1,X2).
entail_lfsr_succ_aux(B1,B2,{X1,X2,X3},Y) =>    % taps = {2,3}
    Y = {Y1,Y2,Y3},
    entail_equiv(B1,B2,Y3,X2),
    entail_equiv(B1,B2,Y2,X1),
    entail_xor(B1,B2,Y1,X2,X3).
entail_lfsr_succ_aux(B1,B2,{X1,X2,X3,X4},Y) =>    % taps = {3,4}
    Y = {Y1,Y2,Y3,Y4},
    entail_equiv(B1,B2,Y4,X3),
    entail_equiv(B1,B2,Y3,X2),
    entail_equiv(B1,B2,Y2,X1),
    entail_xor(B1,B2,Y1,X3,X4).
entail_lfsr_succ_aux(B1,B2,{X1,X2,X3,X4,X5},Y) =>    % taps = {3,5}
    Y = {Y1,Y2,Y3,Y4,Y5},
    entail_equiv(B1,B2,Y5,X4),
    entail_equiv(B1,B2,Y4,X3),
    entail_equiv(B1,B2,Y3,X2),
    entail_equiv(B1,B2,Y2,X1),
    entail_xor(B1,B2,Y1,X3,X5).
entail_lfsr_succ_aux(B1,B2,{X1,X2,X3,X4,X5,X6},Y) =>    % taps = {5,6}
    Y = {Y1,Y2,Y3,Y4,Y5,Y6},
    entail_equiv(B1,B2,Y6,X5),
    entail_equiv(B1,B2,Y5,X4),
    entail_equiv(B1,B2,Y4,X3),
    entail_equiv(B1,B2,Y3,X2),
    entail_equiv(B1,B2,Y2,X1),
    entail_xor(B1,B2,Y1,X5,X6).
entail_lfsr_succ_aux(B1,B2,{X1,X2,X3,X4,X5,X6,X7},Y) =>    % taps = {6,7}
    Y = {Y1,Y2,Y3,Y4,Y5,Y6,Y7},
    entail_equiv(B1,B2,Y7,X6),
    entail_equiv(B1,B2,Y6,X5),
    entail_equiv(B1,B2,Y5,X4),
    entail_equiv(B1,B2,Y4,X3),
    entail_equiv(B1,B2,Y3,X2),
    entail_equiv(B1,B2,Y2,X1),
    entail_xor(B1,B2,Y1,X6,X7).
entail_lfsr_succ_aux(B1,B2,{X1,X2,X3,X4,X5,X6,X7,X8},Y) =>    % taps = {4,5,6,8}
    Y = {Y1,Y2,Y3,Y4,Y5,Y6,Y7,Y8},
    entail_equiv(B1,B2,Y8,X7),
    entail_equiv(B1,B2,Y7,X6),
    entail_equiv(B1,B2,Y6,X5),
    entail_equiv(B1,B2,Y5,X4),
    entail_equiv(B1,B2,Y4,X3),
    entail_equiv(B1,B2,Y3,X2),
    entail_equiv(B1,B2,Y2,X1),
    entail_xor(B1,B2,Y1,X4,X5,X6,X8).
entail_lfsr_succ_aux(B1,B2,{X1,X2,X3,X4,X5,X6,X7,X8,X9},Y) =>    % taps = {5,9}
    Y = {Y1,Y2,Y3,Y4,Y5,Y6,Y7,Y8,Y9},
    entail_equiv(B1,B2,Y9,X8),
    entail_equiv(B1,B2,Y8,X7),
    entail_equiv(B1,B2,Y7,X6),
    entail_equiv(B1,B2,Y6,X5),
    entail_equiv(B1,B2,Y5,X4),
    entail_equiv(B1,B2,Y4,X3),
    entail_equiv(B1,B2,Y3,X2),
    entail_equiv(B1,B2,Y2,X1),
    entail_xor(B1,B2,Y1,X5,X9).
entail_lfsr_succ_aux(B1,B2,{X1,X2,X3,X4,X5,X6,X7,X8,X9,X10},Y) =>    % taps = {7,10}
    Y = {Y1,Y2,Y3,Y4,Y5,Y6,Y7,Y8,Y9,Y10},
    entail_equiv(B1,B2,Y10,X9),
    entail_equiv(B1,B2,Y9,X8),
    entail_equiv(B1,B2,Y8,X7),
    entail_equiv(B1,B2,Y7,X6),
    entail_equiv(B1,B2,Y6,X5),
    entail_equiv(B1,B2,Y5,X4),
    entail_equiv(B1,B2,Y4,X3),
    entail_equiv(B1,B2,Y3,X2),
    entail_equiv(B1,B2,Y2,X1),
    entail_xor(B1,B2,Y1,X7,X10).
entail_lfsr_succ_aux(B1,B2,{X1,X2,X3,X4,X5,X6,X7,X8,X9,X10,X11},Y) =>    % taps = {9,11}
    Y = {Y1,Y2,Y3,Y4,Y5,Y6,Y7,Y8,Y9,Y10,Y11},
    entail_equiv(B1,B2,Y11,X10),
    entail_equiv(B1,B2,Y10,X9),
    entail_equiv(B1,B2,Y9,X8),
    entail_equiv(B1,B2,Y8,X7),
    entail_equiv(B1,B2,Y7,X6),
    entail_equiv(B1,B2,Y6,X5),
    entail_equiv(B1,B2,Y5,X4),
    entail_equiv(B1,B2,Y4,X3),
    entail_equiv(B1,B2,Y3,X2),
    entail_equiv(B1,B2,Y2,X1),
    entail_xor(B1,B2,Y1,X9,X11).
entail_lfsr_succ_aux(B1,B2,{X1,X2,X3,X4,X5,X6,X7,X8,X9,X10,X11,X12},Y) =>    % taps = {4,10,11,12}
    Y = {Y1,Y2,Y3,Y4,Y5,Y6,Y7,Y8,Y9,Y10,Y11,Y12},
    entail_equiv(B1,B2,Y12,X11),
    entail_equiv(B1,B2,Y11,X10),
    entail_equiv(B1,B2,Y10,X9),
    entail_equiv(B1,B2,Y9,X8),
    entail_equiv(B1,B2,Y8,X7),
    entail_equiv(B1,B2,Y7,X6),
    entail_equiv(B1,B2,Y6,X5),
    entail_equiv(B1,B2,Y5,X4),
    entail_equiv(B1,B2,Y4,X3),
    entail_equiv(B1,B2,Y3,X2),
    entail_equiv(B1,B2,Y2,X1),
    entail_xor(B1,B2,Y1,X4,X10,X11,X12).
entail_lfsr_succ_aux(B1,B2,{X1,X2,X3,X4,X5,X6,X7,X8,X9,X10,X11,X12,X13},Y) =>    % taps = {8,11,12,13}
    Y = {Y1,Y2,Y3,Y4,Y5,Y6,Y7,Y8,Y9,Y10,Y11,Y12,Y13},
    entail_equiv(B1,B2,Y13,X12),
    entail_equiv(B1,B2,Y12,X11),
    entail_equiv(B1,B2,Y11,X10),
    entail_equiv(B1,B2,Y10,X9),
    entail_equiv(B1,B2,Y9,X8),
    entail_equiv(B1,B2,Y8,X7),
    entail_equiv(B1,B2,Y7,X6),
    entail_equiv(B1,B2,Y6,X5),
    entail_equiv(B1,B2,Y5,X4),
    entail_equiv(B1,B2,Y4,X3),
    entail_equiv(B1,B2,Y3,X2),
    entail_equiv(B1,B2,Y2,X1),
    entail_xor(B1,B2,Y1,X8,X11,X12,X13).
entail_lfsr_succ_aux(B1,B2,{X1,X2,X3,X4,X5,X6,X7,X8,X9,X10,X11,X12,X13,X14},Y) =>    % taps = {2,12,13,14}
    Y = {Y1,Y2,Y3,Y4,Y5,Y6,Y7,Y8,Y9,Y10,Y11,Y12,Y13,Y14},
    entail_equiv(B1,B2,Y14,X13),
    entail_equiv(B1,B2,Y13,X12),
    entail_equiv(B1,B2,Y12,X11),
    entail_equiv(B1,B2,Y11,X10),
    entail_equiv(B1,B2,Y10,X9),
    entail_equiv(B1,B2,Y9,X8),
    entail_equiv(B1,B2,Y8,X7),
    entail_equiv(B1,B2,Y7,X6),
    entail_equiv(B1,B2,Y6,X5),
    entail_equiv(B1,B2,Y5,X4),
    entail_equiv(B1,B2,Y4,X3),
    entail_equiv(B1,B2,Y3,X2),
    entail_equiv(B1,B2,Y2,X1),
    entail_xor(B1,B2,Y1,X2,X12,X13,X14).

% B => X = Y
% i.e., (~B \/ ~X \/ Y) /\ (~B \/ X \/ ~Y)
entail_equiv(B1,B2,X,Y) =>
    #~B1 #\/ #~B2 #\/ #~X #\/ Y,
    #~B1 #\/ #~B2 #\/ X #\/ #~Y.

% B => Y = X1 ^ X2
entail_xor(B1,B2,Y,X1,X2) =>
    #~B1 #\/ #~B2 #\/ #~Y #\/ X1 #\/ X2,       % 1100 1
    #~B1 #\/ #~B2 #\/ Y #\/ #~X1 #\/ X2,       % 1010 1
    #~B1 #\/ #~B2 #\/ Y #\/ X1 #\/ #~X2,       % 1001 1
    #~B1 #\/ #~B2 #\/ #~Y #\/ #~X1 #\/ #~X2.   % 1111 1

% B => Y = X1 ^ X2 ^ X3 ^ X4
entail_xor(B1,B2,Y,X1,X2,X3,X4) =>
    #~B1 #\/ #~B2 #\/ #~Y #\/ X1 #\/ X2 #\/ X3 #\/ X4,
    #~B1 #\/ #~B2 #\/ Y #\/ #~X1 #\/ X2 #\/ X3 #\/ X4,
    #~B1 #\/ #~B2 #\/ Y #\/ X1 #\/ #~X2 #\/ X3 #\/ X4,
    #~B1 #\/ #~B2 #\/ #~Y #\/ #~X1 #\/ #~X2 #\/ X3 #\/ X4,
    #~B1 #\/ #~B2 #\/ Y #\/ X1 #\/ X2 #\/ #~X3 #\/ X4,
    #~B1 #\/ #~B2 #\/ #~Y #\/ #~X1 #\/ X2 #\/ #~X3 #\/ X4,
    #~B1 #\/ #~B2 #\/ #~Y #\/ X1 #\/ #~X2 #\/ #~X3 #\/ X4,
    #~B1 #\/ #~B2 #\/ Y #\/ #~X1 #\/ #~X2 #\/ #~X3 #\/ X4,
    #~B1 #\/ #~B2 #\/ Y #\/ X1 #\/ X2 #\/ X3 #\/ #~X4,
    #~B1 #\/ #~B2 #\/ #~Y #\/ #~X1 #\/ X2 #\/ X3 #\/ #~X4,
    #~B1 #\/ #~B2 #\/ #~Y #\/ X1 #\/ #~X2 #\/ X3 #\/ #~X4,
    #~B1 #\/ #~B2 #\/ Y #\/ #~X1 #\/ #~X2 #\/ X3 #\/ #~X4,
    #~B1 #\/ #~B2 #\/ #~Y #\/ X1 #\/ X2 #\/ #~X3 #\/ #~X4,
    #~B1 #\/ #~B2 #\/ Y #\/ #~X1 #\/ X2 #\/ #~X3 #\/ #~X4,
    #~B1 #\/ #~B2 #\/ Y #\/ X1 #\/ #~X2 #\/ #~X3 #\/ #~X4,
    #~B1 #\/ #~B2 #\/ #~Y #\/ #~X1 #\/ #~X2 #\/ #~X3 #\/ #~X4.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
global_cardinality(List,Pairs) =>
    (bp.check_pairs(Pairs) -> true; handle_exception($pairs_expected(Pairs), global_cardinality)),
    N = len(List),
    Cards = [Card : $(_-Card) in Pairs],
    (bp.dvar_or_int_list(Cards) ->
        LB = sum([fd_min(Card) : Card in Cards]),
        SumCards :: LB..N,
        SumCards #= sum(Cards),
        Keys = [Key : $(Key-_) in Pairs],        
        (LB == N, ground(Keys) ->
            List :: Keys
        ;
            true
        )
    ;
        true
    ),
    foreach($(Key-Card) in Pairs) 
         sum([B : E in List, B #<=> (E #= Key)]) #= Card
    end.

% neqs(Neqs) => neqs(Neqs).
neqs(Neqs) =>
    (array(Neqs) -> to_list(Neqs) = List; List = Neqs),    
    check_neqs_args(List,List1),
    foreach ('#\\='(X,Y) in List1)
        X #!= Y
    end.

% serialized(Starts,Durations) => serialized(Starts,Durations).
serialized(Starts,Durations) =>
    Len = Starts.length,
    Os = [1 : _ in 1..Len],
    cumulative(Starts,Durations,Os,1).

/************************************************************************* 
    regular(W,Q,S,M,Q0,Fs)

  W : A sentence (an IntVar array or list)
  Q : number of states
  S : input_max, inputs are from 1 to S
  M : transition matrix:  M[I,J] (I in 1..S, J in 1..Q) is a list of outgoing states for NFA (0 means an error).
  Q0: initial state
  Fs : accepting states
***************************************************************************/
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Model 'regular' as a single-agent path finding problem. Initially the agent
% is in state Q0. For each transition step, the agent consumes a token, and
% moves to the next state. At the end, the agent must be in one of the final states.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/*
regular(L, Q, S, M, Q0, Fs) =>
    regular_constr(L, Q, S, M, Q0, Fs, sat).
*/
regular(W, Q, S, M, Q0, Fs) =>
%    writeln($regular(W, Q, S, M, Q0, Fs)),
    check_regular_args(Q,S,M,Q0,Fs,Matrix,FsLst),  % defined in "common_constr.pi"
    (array(W) -> WArr = W; WArr = to_array(W)),
    N = len(WArr),
    bp.domain(vars(W), 1,S),
    N1 = N+1,
    A = new_array(N1,Q),                           % A[T,State] is true if the agent is in State at time T, A[1,Q0] = 1, T = 1..N+1
    B = new_array(N,S),                            % B[T,Input] is true if the agent observed Input at time T 
    transpose_trans_matrix(Matrix,TMatrix),        % defined in "common_constr.pi"
    preprocess_regular_constr_sat(WArr,Q,S,Matrix,TMatrix,Q0,FsLst,A,B,N),

     % initial and final states
    A[1,Q0] = 1,
    foreach (State in 1..Q, State !== Q0)
        A[1,State] = 0
    end,
    regular_exclude_unreachable(1,Q,FsLst,N1,A),   % set A[N1,State] = 0 if State is not in FsLst
    bp.domain(vars(A), 0,1),
    bp.domain(vars(B), 0,1),

    foreach (T in 2..N)
        sum([A[T,State] : State in 1..Q]) #= 1     % at each time, the agent stays in exactly one state
    end,
    sum([A[N1,State] : State in FsLst]) #= 1,      % at time N, the agent is in one of the final states

     % transition constraints
    foreach (State in 1..Q, Input in 1..S)
        Entry = Matrix[State,Input],
        if list(Entry) then
            foreach (T in 1..N, A[T,State] !== 0, B[T,Input] !== 0)
                sum([ #~A[T,State], #~B[T,Input] | [A[T+1,ToState] : ToState in Entry]]) #>= 1
            end
        elseif Entry !== 0 then
            foreach (T in 1..N, A[T,State] !== 0, B[T,Input] !== 0)        
                #~A[T,State] #\/ #~B[T,Input] #\/ A[T+1,Entry]
            end
        else
            foreach (T in 1..N, A[T,State] !== 0, B[T,Input] !== 0)                
                 #~A[T,State] #\/ #~B[T,Input]    % no transition is possible from State on Input
            end
        end
    end,

     % channel constraints
    foreach (T in 1..N, Input in 1..S)
        (WArr[T] #= Input) #<=> B[T, Input]         % this entails sum([B[T,Input] : Input in 1..S]) #= 1
    end.

%% set A[T,State] to 0 if the agent cannot reach State at time T.
%% set B[T,Input] to 0 if the agent cannot consume Input at time T.
%
preprocess_regular_constr_sat(WArr,Q,S,Matrix,TMatrix,Q0,FsLst,A,B,N) =>
    regular_reason_backward_sat(WArr,Q,S,FsLst, len(FsLst), TMatrix,A,B,N+1,Done),
    regular_reason_forward_sat(WArr,Q,S,[Q0],1,Matrix,A,B,1,N,Done),
    (Done == 0 ->
        regular_sdist_heuristic_sat(Q,S,Matrix,TMatrix,Q0,FsLst,A,N)
    ;
        true
    ).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Shortest-distance heuristic: For a state, let D0 be the shortest distance to
% it from Q0. Then the state cannot reached in times 1,..., D0. Likewise, let
% Df be the shortest distance from the state to any final state. Then the state
% cannot be visited in times N-Df+2..N.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
regular_sdist_heuristic_sat(Q,S,Matrix,TMatrix,Q0,FsLst,A,N) =>
    SDFromQ0 = new_array(Q),                                   % SDFromQ0[I], the shortest distance to state I from Q0
    foreach (I in 1..Q)
        SDFromQ0[I] = N
    end,      
    SDFromQ0[Q0] := 0,
    MinHeap1 = new_min_heap([[0|Q0]]),
    fa_shortest_distance(MinHeap1,S,Matrix,SDFromQ0),          % defined in "common_constr.pi"
     %      
    SDFromF = new_array(Q),                                    % SDFromF[I], the shortest distance to I from any state in FsLst
    foreach (I in 1..Q)
        SDFromF[I] = N
    end,      
    foreach (F in FsLst)
        SDFromF[F] := 0
    end,
    MinHeap2 = new_min_heap([[0|FState] : FState in FsLst]),
    fa_shortest_distance(MinHeap2,S,TMatrix,SDFromF),
     %
    foreach (State in 1..Q)
        foreach (T in 2..SDFromQ0[State])
            A[T,State] = 0
        end,
        foreach (T in (N-SDFromF[State]+2)..N)
            A[T,State] = 0
        end
    end.
     %

% Dijkstra's algorithm
fa_shortest_distance(MinHeap,_S,_Matrix,_DistVect), heap_is_empty(MinHeap) => true.
fa_shortest_distance(MinHeap,S,Matrix,DistVect) =>
    [Dist|State] = heap_pop(MinHeap),
    Dist1 = Dist+1,
    foreach (Input in 1..S)
        Entry = Matrix[State,Input],
        if list(Entry) then
            foreach (NextState in Entry)
                if (DistVect[NextState] =< Dist1) then
                    true
                else
                    heap_push(MinHeap,[Dist1|NextState]),
                    DistVect[NextState] := Dist1
                end
            end
       elseif Entry !== 0 then
            if (DistVect[Entry] =< Dist1) then
                true
            else
                heap_push(MinHeap,[Dist1|Entry]),
                DistVect[Entry] := Dist1
            end
        end
    end,
    fa_shortest_distance(MinHeap,S,Matrix,DistVect).

%% When expanding forward, the first frontier is [Q0]. After expanding Front, Font1 becomes the new frontier.
%% Assume the agent is in a state in Front at time T. Then, it will be in a state in Front1 and consume a symbol
%% in Syms at time T+1.
regular_reason_forward_sat(WArr,Q,S,Front,FrontSize,Matrix,A,B,T,N,Done) =>
    (T == N ->
        true
    ; FrontSize == Q ->
        true
    ; FrontSize >= 512 ->
        Done = 0
    ;
        T1 = T+1,
        Wi = WArr[T],
        bp.fd_domain(Wi,Inputs),        
        regular_expand(Inputs,Matrix,Front,Front1,Syms),       % defined in "common_constr.pi"
        regular_exclude_unreachable(1,Q,Front1,T1,A),
        regular_exclude_unreachable(1,S,Syms,T,B),
        regular_reason_forward_sat(WArr,Q,S,Front1, len(Front1), Matrix,A,B,T1,N,Done)
    ).

%% When expanding backward, the first frontier is FsLst at time N
regular_reason_backward_sat(WArr,Q,S,Front,FrontSize,TMatrix,A,B,T,Done) =>
    (T == 2 ->
        true
    ; FrontSize == Q ->
        true
    ; FrontSize >= 512 ->
        Done = 0
    ;
        T1 is T-1,
        Wi = WArr[T1],
        bp.fd_domain(Wi,Inputs),        
        regular_expand(Inputs,TMatrix,Front,Front1,Syms),    
        regular_exclude_unreachable(1,Q,Front1,T1,A),
        regular_exclude_unreachable(1,S,Syms,T1,B),
        regular_reason_backward_sat(WArr,Q,S,Front1, len(Front1), TMatrix,A,B,T1,Done)
    ).

% set Arr[T,Val] = 0 for each Val in 1..Max that is not included in Dom
regular_exclude_unreachable(Val,Max,_Dom,_T,_Arr), Val > Max => true.
regular_exclude_unreachable(Val,Max,[Val|Dom],T,Arr) =>
    regular_exclude_unreachable(Val+1,Max,Dom,T,Arr).
regular_exclude_unreachable(Val,Max,[E|Dom],T,Arr), Val > E =>
    regular_exclude_unreachable(Val,Max,Dom,T,Arr).
regular_exclude_unreachable(Val,Max,Dom,T,Arr) =>
    Arr[T,Val] = 0,
    regular_exclude_unreachable(Val+1,Max,Dom,T,Arr).


%%
%% lex_le(L1,L2): collection L1 is lexicographically less than or equal to L2
%%
lex_le(L1,L2), list(L1), list(L2) =>
    check_args_lex(L1,L2,L11,L22),
    lex_le_aux(L11,L22).
lex_le(L1,L2), array(L1), array(L2) =>
    check_args_lex(to_list(L1), to_list(L2), L11,L22),
    lex_le_aux(L11,L22).
lex_le(L1,L2) =>
    throw($invalid(lex_le(L1,L2))).

%%
%% lex_lt(L1,L2): collection L1 is lexicographically less than L2
%%
lex_lt(L1,L2), list(L1), list(L2) =>
    check_args_lex(L1,L2,L11,L22),
    lex_lt_aux(L11,L22).
lex_lt(L1,L2), array(L1), array(L2) =>
    check_args_lex(to_list(L1), to_list(L2), L11,L22),
    lex_lt_aux(L11,L22).
lex_lt(L1,L2) =>
    throw($invalid(lex_lt(L1,L2))).

check_args_lex(L1,L2,L11,L22) =>
    (bp.dvar_or_int_list(L1) -> true; handle_exception($dvar_list_expected(L1), lex)),
    (bp.dvar_or_int_list(L2) -> true; handle_exception($dvar_list_expected(L2), lex)),
    N1 = length(L1),
    N2 = length(L2),
    (N1 == N2 ->
        L11 = L1, L22 = L2
    ; N1 < N2 ->
        Min = min([fd_min(V) : V in L2]),
        Min1 = Min-1,
        L1Pad = [Min1 : _ in 1..N2-N1],
        L11 = L1 ++ L1Pad, L22 = L2
    ;
        Min = min([fd_min(V) : V in L1]),
        Min1 = Min-1,
        L2Pad = [Min1 : _ in 1..N1-N2],
        L11 = L1, L22 = L2 ++ L2Pad
    ).

% L1 and L2 have the same length 
lex_le_aux([],_) => true.
lex_le_aux([X],[Y|_]) => X #=< Y.
lex_le_aux([X1,X2],[Y1,Y2|_]) => (X1 #< Y1) #\/ (X1 #= Y1 #/\ (X2 #=< Y2)).
lex_le_aux(L1,L2) =>
    N = length(L1),
    A1 = to_array(L1),
    A2 = to_array(L2),
    ReifLexLE = new_array(N),
    ReifLexLE :: 0..1,
    ReifLexLE[N] #<=> (A1[N] #=< A2[N]),
    foreach(I in 2..N-1)
        ReifLexLE[I] #<=> (A1[I] #< A2[I] #\/ ((A1[I] #= A2[I]) #/\ ReifLexLE[I+1]))
    end,
    A1[1] #< A2[1] #\/ ((A1[1] #= A2[1]) #/\ ReifLexLE[2]).

% L1 and L2 have the same length 
lex_lt_aux([],_) => true.
lex_lt_aux([X],[Y|_]) => X #< Y.
lex_lt_aux([X1,X2],[Y1,Y2|_]) => (X1 #< Y1) #\/ (X1 #= Y1 #/\ (X2 #< Y2)).
lex_lt_aux(L1,L2) =>
    N = length(L1),
    A1 = to_array(L1),
    A2 = to_array(L2),
    ReifLexLE = new_array(N),
    ReifLexLE :: 0..1,
    ReifLexLE[N] #<=> (A1[N] #< A2[N]),
    foreach(I in 2..N-1)
        ReifLexLE[I] #<=> (A1[I] #< A2[I] #\/ ((A1[I] #= A2[I]) #/\ ReifLexLE[I+1]))
    end,
    A1[1] #< A2[1] #\/ ((A1[1] #= A2[1]) #/\ ReifLexLE[2]).

%%
nvalue(N,L) => bp.'$nvalue'(N,L).

%% The following constraints are proposed and implemented by Hakan Kjellerstrand
matrix_element(M,I,J,MIJ) =>
    check_matrix(M,NRows,NCols),
    matrix_element(M,NRows,NCols,I,J,MIJ,sat).

%
% Scalar product of the list A and X
%
scalar_product(A, X, Product) => 
    scalar_product(A, X, '#=', Product).

%
% scalar product of List A and X, with one of the relations: 
% 
%   #=, #<, #>, #<=, #>=, #!=
%
scalar_product(A, X, '#=', Product) => 
   check_scalars(A,X),
   sum([A[I]*X[I] : I in 1..A.length]) #= Product.

scalar_product(A, X, '#!=', Product) => 
   check_scalars(A,X),
   sum([A[I]*X[I] : I in 1..A.length]) #!= Product.

scalar_product(A, X, '#>=', Product) => 
   check_scalars(A,X),
   sum([A[I]*X[I] : I in 1..A.length]) #>= Product.

scalar_product(A, X, '#>', Product) => 
   check_scalars(A,X),
   sum([A[I]*X[I] : I in 1..A.length]) #> Product.

scalar_product(A, X, '#<=', Product) => 
   check_scalars(A,X),
    scalar_product(A, X, '#=<', Product).

scalar_product(A, X, '#=<', Product) => 
   check_scalars(A,X),
   sum([A[I]*X[I] : I in 1..A.length]) #=< Product.

scalar_product(A, X, '#<', Product) => 
   check_scalars(A,X),
   sum([A[I]*X[I] : I in 1..A.length]) #< Product.

%
% exactly(?N,?X,?V)
%
% Requires that exactly N variables in X takes the value V.
%
exactly(N, X, V) =>
  count(V,X, #= ,N).

%
% at_most(?N,?X,?V)
%
% Requires that atmost N variables in X takes the value V.
%
at_most(N,X,V) => 
  count(V,X, #=< ,N).

%
% at_least(?N,?X,?V)
%
% Requires that atleast N variables in X takes the value V.
%
at_least(N,X,V) => 
  count(V,X, #>= ,N).

%
% Ensure that List is increasing
%
increasing(FDVars), array(FDVars) =>
   foreach(I in 2..length(FDVars)) FDVars[I-1] #=< FDVars[I] end.
increasing(FDVars), list(FDVars) =>
   increasing_list(FDVars).
increasing(FDVars) =>
   handle_exception($list_or_array_expected(FDVars), increasing).

increasing_list([]) => true.
increasing_list([_]) => true.
increasing_list([X|T@[Y|_]]) => 
    X #=< Y,
    increasing_list(T).

increasing_strict(FDVars), array(FDVars) =>
   foreach(I in 2..length(FDVars)) FDVars[I-1] #< FDVars[I] end.
increasing_strict(FDVars), list(FDVars) =>
   increasing_strict_list(FDVars).
increasing_strict(FDVars) =>
   handle_exception($list_or_array_expected(FDVars), increasing_strict).

increasing_strict_list([]) => true.
increasing_strict_list([_]) => true.
increasing_strict_list([X|T@[Y|_]]) => 
    X #< Y,
    increasing_strict_list(T).

%
% Ensure that FDVars is decreasing
%
decreasing(FDVars), array(FDVars) =>
   foreach(I in 2..length(FDVars)) FDVars[I-1] #>= FDVars[I] end.
decreasing(FDVars), list(FDVars) =>
   decreasing_list(FDVars).
decreasing(FDVars) =>
   handle_exception($list_or_array_expected(FDVars), decreasing).

decreasing_list([]) => true.
decreasing_list([_]) => true.
decreasing_list([X|T@[Y|_]]) => 
    X #>= Y,
    decreasing_list(T).

decreasing_strict(FDVars), array(FDVars) =>
   foreach(I in 2..length(FDVars)) FDVars[I-1] #> FDVars[I] end.
decreasing_strict(FDVars), list(FDVars) =>
   decreasing_strict_list(FDVars).
decreasing_strict(FDVars) =>
   handle_exception($list_or_array_expected(FDVars), decreasing_strict).

decreasing_strict_list([]) => true.
decreasing_strict_list([_]) => true.
decreasing_strict_list([X|T@[Y|_]]) => 
    X #> Y,
    decreasing_strict_list(T).
