module sat.
import common_constr.

% '#!='(X,Y) =>  X #!= Y.
% '#/\\'(X,Y) =>  X #/\ Y.
% '#<'(X,Y) =>  X #< Y.
% '#<='(X,Y) =>  X #=< Y.
% '#<=>'(X,Y) =>  X #<=> Y.
% '#='(X,Y) => X #= Y.
% '#=<'(X,Y) =>  X #=< Y.
% '#=>'(X,Y) =>  X #=> Y.
% '#>'(X,Y) =>  X #> Y.
% '#>='(X,Y) =>  X #>= Y.
% '#\\/'(X,Y) =>  X #\/ Y.
% '#^'(X,Y) =>  X #^ Y.
% '#~'(X) =>  #~ X.
%  '::'(Vars,Domain) => '::'(Vars,Domain).
% all_different(FDVars) => all_different(FDVars).
% all_different_except_0(Xs) => all_different_except_0(Xs).
% all_distinct(FDVars) => all_distinct(FDVars).
% assignment(FDVars1,FDVars2) => assignment(FDVars1,FDVars2).
% at_least(N,X,V) => at_least(N,X,V).
% at_most(N,X,V) => at_most(N,X,V).
% circuit(L) => circuit(L).
% count(V,FDVars,Rel,N) => count(V,FDVars,Rel,N).
% cumulative(Starts,Durations,Resources,Limit) => cumulative(Starts,Durations,Resources,Limit).
% decreasing(FDVars) => decreasing(FDVars).
% decreasing_strict(FDVars) => decreasing_strict(FDVars).
% diffn(RectangleList) => diffn(RectangleList).
% disjunctive_tasks(Tasks) => disjunctive_tasks(Tasks).
% element(I,FDVars,V) => element(I,FDVars,V).
% exactly(N, X, V) => exactly(N, X, V).
% fd_disjoint(DVar1,DVar2) => fd_disjoint(DVar1,DVar2).
% fd_dom(FDVar) = fd_dom(FDVar).
% fd_false(FDVar,Elm) => fd_false(FDVar,Elm).
% fd_max(FDVar) = fd_max(FDVar).
% fd_min(FDVar) = fd_min(FDVar).
% fd_min_max(FDVar,Min,Max) => fd_min_max(FDVar,Min,Max).
% fd_next(FDVar,Elm) = fd_next(FDVar,Elm).
% fd_prev(FDVar,Elm) = fd_prev(FDVar,Elm).
% fd_set_false(FDVar,Elm) => fd_set_false(FDVar,Elm).
% fd_size(FDVar) = fd_size(FDVar).
% fd_true(FDVar,Elm) => fd_true(FDVar,Elm).
% fd_vector_min_max(Min,Max) => fd_vector_min_max(Min,Max).
% global_cardinality(FDVars,Pairs) => global_cardinality(FDVars,Pairs).
% increasing(FDVars) => increasing(FDVars).
% increasing_strict(FDVars) => increasing_strict(FDVars).
% lex_le(L1,L2) = > lex_le(L1,L2).
% lex_lt(L1,L2) = > lex_lt(L1,L2).
% matrix_element(M,I,J,MIJ) => matrix_element(M,I,J,MIJ).
% neqs(Neqs) => neqs(Neqs).
% new_dvar() = new_dvar().
% new_fd_var() = new_fd_var().
% notin(VarOrVars,D) => notin(VarOrVars,D).
% nvalue(N,L) => nvalue(N,L).
% regular(W, Q, S, M, Q0, Fs) => regular(W, Q, S, M, Q0, Fs).
% scalar_product(A, X, Product) => scalar_product(A, X, Product).
% serialized(Starts,Durations) => serialized(Starts,Durations).
% solve(Options,Vars) => solve(Options,Vars)
% solve(Vars) => solve(Vars).
% solve_all(Options,Vars) = solve_all(Options,Vars).
% solve_all(Vars) = solve_all(Vars).
% subcircuit(FDVars) => subcircuit(FDVars).
% subcircuit_grid(A) => subcircuit_grid(A).
% subcircuit_grid(A,K) => subcircuit_grid(A,K).
% table_in(Vars, Tuples) => table_in(Vars, Tuples).
% table_notin(Vars, Tuples) => table_notin(Vars, Tuples).

'::'(Vars,Domain) =>
    bp.'_$_picat_in'(sat,Vars,Domain).

% '#='(X,Y) => X #= Y.
'#='(X,Y) => bp.'$='(X,Y).

% '#>='(X,Y) =>  X #>= Y.
'#>='(X,Y) => bp.'$>='(X,Y).

% '#>'(X,Y) =>  X #> Y.
'#>'(X,Y) => bp.'$>'(X,Y).

% '#<'(X,Y) =>  X #< Y.
'#<'(X,Y) => bp.'$<'(X,Y).

% '#=<'(X,Y) =>  X #=< Y.
'#=<'(X,Y) => bp.'$=<'(X,Y).

% '#!='(X,Y) =>  X #!= Y.
'#!='(X,Y) => bp.'$\\='(X,Y).

'#\\='(X,Y) => bp.'$\\='(X,Y).

% '#<=>'(X,Y) =>  X #<=> Y.
'#<=>'(X,Y) => bp.'$<=>'(X,Y).

% '#=>'(X,Y) =>  X #=> Y.
'#=>'(X,Y) => 
   bp.'$=>'(X,Y).

% '#/\\'(X,Y) =>  X #/\ Y.
'#/\\'(X,Y) => bp.'$/\\'(X,Y).

% '#\\/'(X,Y) =>  X #\/ Y.
'#\\/'(X,Y) => bp.'$\\/'(X,Y).

% '#^'(X,Y) =>  X #^ Y.
'#^'(X,Y) => bp.'$\\'(X,Y).

% '#~'(X) =>  #~ X.
'#~'(X) => bp.'$\\'(X).

% all_different(FDVars) => all_different(FDVars).
all_different(FDVars) =>
    (array(FDVars) -> to_list(FDVars)=List; List=FDVars),
    bp.'$alldifferent'(List).

% all_distinct(FDVars) => all_distinct(FDVars).
all_distinct(FDVars) =>
    all_different(FDVars).

%
% Requires that all non-zero values in Xs be distinct.
%
alldifferent_except_0(Xs) =>
    all_different_except_0(Xs).

all_different_except_0(Xs) =>
    foreach(I in 1..Xs.length, J in 1..I-1)
        Xs[I] #= 0 #\/ Xs[J] #= 0 #\/ Xs[I] #!= Xs[J]
    end.

% element(I,FDVars,V) => element(I,FDVars,V).
element(I,FDVars,V) =>
    (array(FDVars) -> to_list(FDVars)=List; List=FDVars),
    (bp.dvar_or_int_list(List) -> true; handle_exception($dvar_or_int_list_expected(List),element)),
    bp.'$element'(I,List,V,sat).

% fd_disjoint(DVar1,DVar2) => fd_disjoint(DVar1,DVar2).
fd_disjoint(DVar1,DVar2),dvar_or_int(DVar1),dvar_or_int(DVar2) => bp.b_DM_DISJOINT_cc(DVar1,DVar2).
fd_disjoint(DVar1,DVar2) =>
    Source=fd_disjoint,
    (dvar_or_int(DVar1) -> handle_exception($dvar_expected(DVar2),Source);handle_exception($dvar_expected(DVar1),Source)).

% fd_set_false(FDVar,Elm) => fd_set_false(FDVar,Elm).
fd_set_false(FDVar,Elm), dvar_or_int(FDVar),integer(Elm) => 
    bp.domain_set_false(FDVar,Elm).
fd_set_false(FDVar,Elm) =>
    Source=fd_set_false,
    (integer(Elm) ->
        handle_exception($dvar_expected(FDVar),Source)
    ;
        handle_exception($integer_expected(Elm),Source)
    ).

% count(V,FDVars,Rel,N) => count(V,FDVars,Rel,N).
count(V,FDVars,Rel,N) =>
    (array(FDVars) -> to_list(FDVars)=List; List=FDVars),
    reified_bool_vars(List,V,Bs),
    count_aux(Bs,Rel,N).

reified_bool_vars([],_V,Bs) => Bs=[].
reified_bool_vars([E|List],V,Bs) =>
    Bs = [B|BsR],
    B #<=> (V #= E),
    reified_bool_vars(List,V,BsR).

count_aux(Bs,'#=',N) => sum(Bs) #= N.
count_aux(Bs,'#!=',N) => sum(Bs) #!= N.
count_aux(Bs,'#\\=',N) => sum(Bs) #!= N.
count_aux(Bs,'#>',N) => sum(Bs) #> N.
count_aux(Bs,'#>=',N) => sum(Bs) #>= N.
count_aux(Bs,'#<',N) => sum(Bs) #< N.
count_aux(Bs,'#=<',N) => sum(Bs) #=< N.
count_aux(Bs,'#<=',N) => sum(Bs) #=< N.

count(V,FDVars,N) =>
    count(V,FDVars,'#=',N).

% cumulative(Starts,Durations,Resources,Limit) => cumulative(Starts,Durations,Resources,Limit).
cumulative(Starts,Durations,Resources,Limit) =>
    (array(Starts) -> to_list(Starts)=SList; SList=Starts),    
    (array(Durations) -> to_list(Durations)=DList; DList=Durations),    
    (array(Resources) -> to_list(Resources)=RList; RList=Resources),
%    println($cumu(Starts,Durations,Resources,Limit)),
    bp.bp_cumulative(SList,DList,RList,Limit,sat).
    
% diffn(RectangleList) => diffn(RectangleList).
diffn(RectangleList) =>
    (array(RectangleList) -> to_list(RectangleList)=RList; RList=RectangleList),
    bp.bp_diffn(RList,sat).

% disjunctive_tasks(Tasks) => disjunctive_tasks(Tasks).
disjunctive_tasks(Tasks) =>
    (array(Tasks) -> to_list(Tasks)=TList; TList=Tasks),    
    disjunctive_tasks_aux(TList).

disjunctive_tasks_aux([]) => true.
disjunctive_tasks_aux([disj_tasks(S1,D1,S2,D2)|Tasks]) =>
    S1+D1 #=< S2 #\/ S2+D2 #=< S1,
    disjunctive_tasks_aux(Tasks).
disjunctive_tasks_aux(Tasks) =>
    handle_exception($invalid_tasks(Tasks),disjunctive_tasks).

% assignment(FDVars1,FDVars2) => assignment(FDVars1,FDVars2).
assignment(FDVars1,FDVars2) =>
    bp.picat_preprocess_assignment(FDVars1,FDVars2,Vect1,Vect2,N),
    M1 = new_array(N,N),                        % M1[I,J] = 1 iff FDVars1[I] = J
    M1 :: 0..1,
    M2 = new_array(N,N),                        % M2[I,J] = 1 iff FDVars2[I] = J
    foreach (I in 1..N, J in 1..N)              % M2 is M1's transpose
        M2[I,J] = M1[J,I]
    end,
    foreach (I in 1..N, J in 1..N)              % channel
        M1[I,J] #<=> Vect1[I] #= J,
        M2[I,J] #<=> Vect2[I] #= J
    end,
    foreach (J in 1..N)                         
        sum([M1[I,J] : I in 1..N]) #= 1         % all_different(FDVars1),
    end.


% solve(Vars) => solve(Vars).
solve(Vars) => solve([],Vars).

% solve(Options,Vars) => solve(Options,Vars)
solve(Options,Vars) =>
    (bp.dvar_or_int_list(Vars) ->
        VList = Vars
    ;
        VList = vars(Vars),
        (bp.dvar_or_int_list(VList) ->
            true
        ;
            handle_exception($free_var_not_allowed(Vars),solve)
        )
    ),
    (select($report(Call),Options,Options1) ->
        Options2 = [$report('$dyna_eval_pred'(['$picat_top_level'],Call))|Options1]
    ;
        Options2 = Options
    ),
    (select($dump(File),Options2,Options3) ->
        AtomFile = to_atom(File),
        Options4 = [$dump(AtomFile)|Options3]
    ;         
        Options4 = Options2
    ),        
    bp.sat_solve(Options4,VList).    

solve_all(Vars) = solve_all([],Vars).

solve_all(Options,Vars) =
    findall(Vars,solve(Options,Vars)).

%%%%%%%%%%%%%%%%%%%%%%%% common to cp and sat modules %%%%%%%%%%%%%%%%%%%%%%
% new_fd_var() = new_fd_var().
new_fd_var() = FDVar =>
    bp.fd_new_var(FDVar).

new_dvar() = FDVar =>
    bp.fd_new_var(FDVar).

%%
table_in(Vars,Tuples) =>
    bp.'$table_in'(Vars,Tuples).

%%
notin(Vars,Domain) =>
    bp.'_$_picat_notin'(sat,Vars,Domain).

%%
table_notin(Vars,Tuples) =>
    bp.'$table_notin'(Vars,Tuples).

% fd_dom(FDVar) = fd_dom(FDVar).
fd_dom(FDVar) = List,integer(FDVar) => List=[FDVar].
fd_dom(FDVar) = List, dvar(FDVar) => bp.domain_min_max(FDVar,Min,Max),bp.fd_domain(FDVar,List,Min,Max).
fd_dom(FDVar) = _List => 
    handle_exception($dvar_expected(FDVar),fd_dom).

% fd_false(FDVar,Elm) => fd_false(FDVar,Elm).
fd_false(FDVar,Elm),
    dvar_or_int(FDVar),
    integer(Elm)
=>
    bp.b_DM_FALSE_cc(FDVar,Elm).
fd_false(FDVar,Elm) =>
    bp.expect_dvar_int(FDVar,Elm,fd_false).

% fd_max(FDVar) = fd_max(FDVar).
fd_max(FDVar) = Max => (dvar_or_int(FDVar)->bp.domain_min_max(FDVar,_,Max);handle_exception($dvar_expected(FDVar),fd_max)).

% fd_min(FDVar) = fd_min(FDVar).
fd_min(FDVar) = Min => (dvar_or_int(FDVar)->bp.domain_min_max(FDVar,Min,_);handle_exception($dvar_expected(FDVar),fd_min)).

% fd_min_max(FDVar,Min,Max) => fd_min_max(FDVar,Min,Max).
fd_min_max(FDVar,Min,Max) => 
    (dvar_or_int(FDVar)->
    bp.domain_min_max(FDVar,Min,Max)
    ;
        handle_exception($dvar_expected(FDVar),fd_min_max)
    ).

% fd_next(FDVar,Elm) = fd_next(FDVar,Elm).
fd_next(FDVar,Elm) = NextElm, 
    dvar(FDVar), integer(Elm) 
=>
    (bp.domain_next_inst(FDVar,Elm,NextElm) -> true; handle_exception(failed,fd_next)).
fd_next(FDVar,Elm) = _NextElm =>
    bp.expect_dvar_int(FDVar,Elm,fd_next).

% fd_prev(FDVar,Elm) = fd_prev(FDVar,Elm).
fd_prev(FDVar,Elm) = PrevElm,
    dvar(FDVar), integer(Elm) 
=>
    (bp.b_DM_PREV_ccf(FDVar,Elm,PrevElm) -> true; handle_exception(failed,fd_prev)).
fd_prev(FDVar,Elm) = _PrevElm =>
    bp.expect_dvar_int(FDVar,Elm,fd_prev).

% fd_size(FDVar) = fd_size(FDVar).
fd_size(FDVar) = Size =>
    (dvar(FDVar) -> 
        bp.b_DM_COUNT_cf(FDVar,Size)
    ;integer(FDVar) ->
        Size=1
    ;
        handle_exception($dvar_expected(FDVar),fd_size)
    ).
    
% fd_true(FDVar,Elm) => fd_true(FDVar,Elm).
fd_true(FDVar,Elm),
    dvar_or_int(FDVar),
    integer(Elm)
=>
    bp.b_DM_TRUE_cc(FDVar,Elm).
fd_true(FDVar,Elm) =>
    bp.expect_dvar_int(FDVar,Elm,fd_true).

fd_vector_min_max(Min,Max) =>
    bp.fd_vector_min_max(Min,Max).

/************************************************************************* 
circuit(L): L is a list of variables X1,X2,...,Xn. An assignment
{X1->a1,X2->a2,...,Xn->an} satisfies this constraint if it forms a Hamilton cycle. 
To be more specific, each variable has a different value and no sub-cycles can be 
formed.  For example, for the constraint circult([X1,X2,X3,X4]), 
[3,4,2,1] is a solution, but [2,1,4,3] is not because it contains sub-cycles.
*************************************************************************/
circuit(L),list(L) =>
    A = to_array(L),
    circuit_aux(A).
circuit(A),array(A) =>
    circuit_aux(A).
circuit(L) =>
    handle_exception($array_or_list_expected(L),circuit).

circuit_aux({V}) => V = 1.
circuit_aux(A) =>                            % single-agent path finding
    N = length(A),
    A :: 1..N,
    foreach (I in 1..N)                      % not reflexive
        bp.domain_set_false(A[I],I)
    end,
    circuit_init_adj_matrix(H,A,N,NeibVect,TNeibVect),
    
    H :: 0..1,
    foreach (I in 1..N, J in 1..N, I !== J)  % channel
        if H[I,J] !== 0 then
            H[I,J] #<=> (A[I] #= J),
            if N > 2 then
                #~H[I,J] #\/ #~H[J,I]
            end
        end
    end,
    foreach (I in 1..N)                       
        sum([H[J,I] : J in 1..N]) #= 1        % each node has exactly one incoming edge
    end,

    circuit_choose_start(A,1,fd_size(A[1]),Start,1,N),
    % ban sub-cycles
    P = new_array(N),                         % P[I] is node I's position
    P[Start] = 1,
    P :: 1..N,
    circuit_preprocess(N,P,Start,NeibVect,TNeibVect),
    % if H[Start,I] then node I is visited after node Start; if node I is visited at time N, then (I,Start) must be in
    foreach (I in 1..N, I !== Start)
        H[Start,I] #=> P[I] #= 2,        % H[Start,I] -> I is the successor of Start
        H[I,Start] #=> (P[I] #= N)       % H[I,Start] -> I is visited at time N
    end,
    % if edge (I,J) is in, and J's position is the successor of I's position
    foreach (I in 1..N, I !== Start, J in 1..N, J !== Start, H[I,J] !== 0)
        H[I,J] #=> P[J] #= P[I]+1
    end.

% H is the adjacent matrix representation of a Hamilton cycle in graph A
% set H[I,J] = 0 if (I,J) is not an edge in graph A
circuit_init_adj_matrix(H,A,N,NeibVect,TNeibVect) =>
    H = new_array(N,N),                        % H[I,J] = 1 iff (I,J) an edge in the Hamilton cycle
    NeibVect = new_array(N),                   % adjacency list
    TNeibVect = new_array(N),                  % adjacency list of the transpose graph
    foreach (I in 1..N, J in 1..N)             % H is a subgraph of A
        if fd_true(A[I],J) then
            true
        else
            H[I,J] = 0
        end
    end,
    foreach (I in 1..N)
        NeibVect[I] = [J : J in 1..N, H[I,J] !== 0],
        TNeibVect[I] = [J : J in 1..N, H[J,I] !== 0]
    end.

% choose a node that has the smallest out-degree to start with
circuit_choose_start(_A,CurIndex,_CurDeg,BestIndex,I,N), I > N => BestIndex = CurIndex.
circuit_choose_start(A,CurIndex,CurDeg,BestIndex,I,N) =>
    X = A[I],
    Deg = fd_size(X),
    (Deg < CurDeg ->
        CurIndex1 = I,
        CurDeg1 = Deg
    ;
        CurIndex1 = CurIndex,
        CurDeg1 = CurDeg
    ),
    circuit_choose_start(A,CurIndex1,CurDeg1,BestIndex,I+1,N).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Shortest-distance heuristic: For a node, let D0 be the shortest distance to
% it from Start. Then the node cannot be reached at times 1,..., D0, because
% Start is visited at time 1. Likewise, let D1 be the shortest distance from
% the node to Start. Then the node cannot be visited at times (N-D1+2)..N.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
circuit_preprocess(N,P,Start,NeibVect,TNeibVect) =>
    (NeibVect == TNeibVect -> Undirected = 1; Undirected = 0),
    circuit_reason_forward(Start,[Start],1,NeibVect,P,1,N,Done),
    circuit_reason_backward(Start,[Start],1,TNeibVect,P,N+1,N,Undirected,Done),
    if Done == 0 then    % some frontiers are too large to expand, so use the shortest-distance heuristic
        circuit_shortest_distance0(Start,N,NeibVect,SDFromStart),
        circuit_shortest_distance0(Start,N,TNeibVect,SDToStart),
        foreach (I in 1..N, I !== Start)
            foreach (T in 1..SDFromStart[I])
                bp.domain_set_false(P[I], T)
            end,
            foreach (T in (N-SDToStart[I]+2)..N)
                bp.domain_set_false(P[I], T)
            end
        end
    end.
    
circuit_shortest_distance0(Start,N,NeibVect,DistVect) =>
    DistVect = new_array(N),                               % DistVect[I], the shortest distance from Start to node I
    foreach (I in 1..N)
        DistVect[I] = N
    end,      
    DistVect[Start] := 0,
    MinHeap1 = new_min_heap([[0|Start]]),
    circuit_shortest_distance(MinHeap1,N,NeibVect,DistVect).

% Dijkstra's algorithm
circuit_shortest_distance(MinHeap,_N,_NeibVect,_DistVect), heap_is_empty(MinHeap) => true.
circuit_shortest_distance(MinHeap,N,NeibVect,DistVect) =>
    [Dist|Node] = heap_pop(MinHeap),
    Dist1 = Dist+1,
    foreach (Neib in NeibVect[Node])
        if (DistVect[Neib] =< Dist1) then
            true
        else
            heap_push(MinHeap,[Dist1|Neib]),
            DistVect[Neib] := Dist1
        end
    end,
    circuit_shortest_distance(MinHeap,N,NeibVect,DistVect).

%% When expanding forward, the first frontier is [Start] at time 1. After expanding Front, Font1 becomes the new frontier.
%% Assume the agent is in a state in Front at time T. Then, it will be in a state in Front1 at time T+1.
circuit_reason_forward(Start,Front,FrontSize,NeibVect,P,T,N,Done) =>
    (T == N ->
        true
    ; FrontSize =< 512, FrontSize < N-1 ->
        T1 is T+1,
        circuit_expand(Start,NeibVect,Front,Front1),
        circuit_exclude_unreachable(1,N,Front1,P,T1),
        circuit_reason_forward(Start,Front1,len(Front1),NeibVect,P,T1,N,Done)
    ; 
        Done = 0
    ).

%% When expanding backward, the first frontier is [Start] at time N+1
circuit_reason_backward(Start,Front,FrontSize,TNeibVect,P,T,N,Undirected,Done) =>
    (T == 2 ->
        true
    ; FrontSize =< 512, FrontSize < N-1 ->
        T1 is T-1,
        circuit_expand(Start,TNeibVect,Front,Front1),
        circuit_exclude_unreachable(1,N,Front1,P,T1),
        FrontSize1 = len(Front1),        
        if FrontSize1 == 2 && Undirected == 1 then    % the distance to Start is N-T1+1
            Front1 = [X1,X2],                         % visit one at time N-T1+2 and visit the other at time T1
            foreach (TT in N-T1+3..T1-1)
                bp.domain_set_false(P[X1],TT),
                bp.domain_set_false(P[X2],TT)
            end
        end,
        circuit_reason_backward(Start,Front1,FrontSize1,TNeibVect,P,T1,N,Undirected,Done)
    ;
        Done = 0
    ).

% Expand Front to yield the next frontier Front1.
circuit_expand(Start,NeibVect,Front,Front1) =>
    TmpFront = [J : I in Front, J in NeibVect[I], J !== Start],
    Front1 = sort_remove_dups(TmpFront).

% for each E in 1..Max that is not included in Dom, E cannot be mapped to position Pos
circuit_exclude_unreachable(E,Max,_Dom,_P,_Pos), E > Max => true.
circuit_exclude_unreachable(E,Max,[E|Dom],P,Pos) =>
    circuit_exclude_unreachable(E+1,Max,Dom,P,Pos).
circuit_exclude_unreachable(E,Max,[Ed|Dom],P,Pos), E > Ed =>
    circuit_exclude_unreachable(E,Max,Dom,P,Pos).
circuit_exclude_unreachable(E,Max,Dom,P,Pos) =>
    bp.domain_set_false(P[E],Pos),
    circuit_exclude_unreachable(E+1,Max,Dom,P,Pos).

/************************************************************************* 
subcircuit(L):  L is a list or an array of variables X1,X2,...,Xn.
L forms a subcircuit where Xi = j (j \= i) means that j is the successor of i 
and Xi = i means that i is not in the circuit. No sub-cycles are allowed.
*************************************************************************/
subcircuit(L),list(L) =>
    subcircuit_aux(L.to_array()).
subcircuit(A),array(A) =>
    subcircuit_aux(A).
subcircuit(L) =>
    handle_exception($array_or_list_expected(L),subcircuit).

%% use LFSR (left-feedback-shift-register) encoding
subcircuit_aux(A), subcircuit_no_loop(A) =>
    circuit_aux(A).
subcircuit_aux({V}) => V = 1.
subcircuit_aux(A) =>
    A.length = N,
    A :: 1..N,
    H = new_array(N,N),                         % H[I,I] = 1 means node I is not in the circuit
    subcircuit_init_adj_matrix(H,A,N),
    H :: 0..1,
    foreach (I in 1..N, J in 1..N)              % channel
        if H[I,J] !== 0 then
            H[I,J] #<=> (A[I] #= J)
        end
    end,
    foreach (I in 1..N)                         % each node has exactly one incoming edge
        sum([H[J,I] : J in 1..N]) #= 1        
    end,
    %
    subcircuit_choose_start(A,0,N,Start,1,N),
    % ban sub-cycles
    FirstIn = new_array(N),
    (Start !== 0 ->
        FirstIn[Start] = 1,
        foreach (I in 1..N, I !== Start)
            FirstIn[I] = 0
        end
    ;
        FirstIn :: 0..1,
        sum(FirstIn) #=< 1                      % no node is first if the circuit is empty
    ),
    %
    OrderM = new_array(N,N),                    % order the nodes in the circuit, starting at I for which FirstIn[I]=1
    foreach(I in 1..N) OrderM[I,I] = 0 end,     % not reflexive
    OrderM :: 0..1,
    foreach (I in 1..N)
        FirstIn[I] #=> #~ H[I,I],
        foreach (J in 1..N, I !== J)
            FirstIn[I] #=> #~OrderM[J,I],
            H[I,J] #/\ #~ FirstIn[J] #=> OrderM[I,J],
            OrderM[I,J]+OrderM[J,I] #=< 1       % both could be 0
        end
    end,
    foreach (I in 1..N, K in 1..N, H[I,K] !== 0, J in 1..N, I !== J)
        #~FirstIn[K] #/\ #~FirstIn[J] #/\ H[I,K] #/\ OrderM[K,J] #=> OrderM[I,J]
    end.

subcircuit_no_loop(A) =>
    N = len(A),
    foreach (I in 1..N)
        fd_false(A[I],I)
    end.

subcircuit_init_adj_matrix(H,A,N) =>
    foreach (I in 1..N, J in 1..N)                   % H is a subgraph of A
        if fd_true(A[I],J) then
            true
        else
            H[I,J] = 0
        end
    end.

% choose a node that is guaranteed to be in the cycle and has the smallest out-degree to start with
subcircuit_choose_start(_A,CurIndex,_CurDeg,BestIndex,I,N), I > N => BestIndex = CurIndex.
subcircuit_choose_start(A,CurIndex,CurDeg,BestIndex,I,N) =>
    X = A[I],
    Deg = fd_size(X),
    (fd_false(X,I), Deg < CurDeg ->      % fd_false(X,I) means I cannot be a loop, and must be in the cycle
        CurIndex1 = I,
        CurDeg1 = Deg
    ;
        CurIndex1 = CurIndex,
        CurDeg1 = CurDeg
    ),
    subcircuit_choose_start(A,CurIndex1,CurDeg1,BestIndex,I+1,N).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% A is a two-dimensional array. All the non-zero cells of A form a Hamiltonian cycle
% A[R,C] is filled with 0 if it's known to be not in the cycle.
% The total number of non-zero cells is K
%
subcircuit_grid(A) =>
    subcircuit_grid(A,_).

subcircuit_grid({},K) => K = 0.
subcircuit_grid(A,K) =>
    (array(A) -> true; handle_exception($array_expected(A),subcircuit_grid)),
    NRows = len(A),
    foreach (R in 1..NRows)
        (array(A[R]) -> true; handle_exception($array_expected(A[R]),subcircuit_grid))
    end,
    A :: 0..1,
    NCols = len(A[1]),
    NZeros = sum([1 : R in 1..NRows, C in 1..NCols, A[R,C] == 0]),
    NCells = max(NRows*NCols-NZeros,1),
    %
    K :: 0..NCells,
    sum([A[R,C] : R in 1..NRows, C in 1..NCols, A[R,C] !== 0]) #= K,
    KGtOne #<=> (K #> 1),
    KGtTwo #<=> (K #> 2),
    KGtTwo #=> KGtOne,
    %
    H = new_array(NRows,NCols),    % H[R,C] = [{R1,C1,B1},{R2,C2,B2},...], Bi <=> (R,C) and (Ri,Ci) are connected in the circuit
    foreach (R in 1..NRows, C in 1..NCols)
        (A[R,C] !== 0 ->
            Neibs = [{R1,C1,B} : (Dr,Dc) in [(-1,0),(1,0),(0,-1),(0,1)],
                                   R1 = R+Dr, C1 = C+Dc, R1 >= 1, R1 =< NRows, C1 >= 1, C1 =< NCols, A[R1,C1] !== 0, B :: 0..1],
            H[R,C] = Neibs
        ;
            H[R,C] = []
        )
    end,
    foreach (R in 1..NRows, C in 1..NCols, A[R,C] !== 0)
        Neibs = H[R,C],
        OutBs = [B : {_,_,B} in Neibs],
        foreach ({_,_,B} in Neibs)
            A[R,C] #\/ #~B
        end,
        LenOutBs = len(OutBs),
        bp.attach_complex_imp([#~A[R,C], #~KGtOne], $ic_bool_sum(eq,OutBs,LenOutBs,1)),   % one outgoing
        InBs = [],
        foreach ({R1,C1,_} in Neibs, member({R,C,B}, H[R1,C1]))
            A[R,C] #\/ #~B,
            InBs := [B|InBs]
        end,
        LenInBs = len(InBs),
        bp.attach_complex_imp([#~A[R,C], #~KGtOne], $ic_bool_sum(eq,InBs,LenInBs,1))      % one incoming
    end,
    % ban sub-cycles
    Start = new_array(NRows,NCols),    
    Start :: 0..1,                          % Start[R,C]=1 iff the cycle starts at (R,C)
    foreach (R in 1..NRows, C in 1..NCols)
        (A[R,C] == 0 ->
            Start[R,C] = 0
        ;
            #~A[R,C]  #=> #~Start[R,C]
        )
    end,
    StartList = [{R,C,Start[R,C]} : R in 1..NRows, C in 1..NCols, A[R,C] !== 0],        
    HasStartedList = new_list(NCells),    % HasStarted[R,C] iff there exists (R1,C1) in {(1,1) ... (R,C)} such that Start[R1,C1]
    HasStartedList :: 0..1,
    constr_start(A,StartList,HasStartedList,KGtOne),
    %
    P = new_array(NRows,NCols),
    NB is round(log(2,NCells)+0.5),                % number of bits needed by the log encoding
    Max is 2**NB-1,
    P :: 0..Max,
    foreach (R in 1..NRows, C in 1..NCols)
        (A[R,C] == 0 ->
            P[R,C] = 0
        ;
            bp.sat_encode_dvar(P[R,C],_)           % get the log encoding
        )
    end,
    foreach (R in 1..NRows, C in 1..NCols, A[R,C] !== 0)
        #~A[R,C] #<=> P[R,C] #= 0,
        Start[R,C] #<=> P[R,C] #= 1,
        Neibs = H[R,C],
        foreach ({R1,C1,B} in Neibs)
            once member({R,C,B1}, H[R1,C1]),
            #~KGtTwo #\/ #~B #\/ #~B1,              % no cycle of size 2
            entail_lfsr_succ(NB, #~Start[R1,C1], B, P[R,C], P[R1,C1])
        end
    end.

% Start and HasStarted must follow the following pattern:
%      Start = 0 ... 0 1 0 ... 0
% HasStarted = 0 ... 0 1 1 ... 1
%
constr_start(_A,[],_HasStartedList,_KGtOne) => true.
constr_start(A,[{R,C,StartB}|StartList],[HasStartedB|HasStartedList],KGtOne) =>
     A[R,C] #<=> StartB,
     A[R,C] #<=> HasStartedB,
     constr_start(A,HasStartedB,StartList,HasStartedList,KGtOne).

constr_start(_A,_HasStartedB,[],_HasStartedList,_KGtOne) => true.
constr_start(A,PrevHasStartedB,[{R,C,StartB}|StartList],[HasStartedB|HasStartedList],KGtOne) =>
     PrevHasStartedB #=> HasStartedB,
     A[R,C] #/\ #~PrevHasStartedB #=> StartB,
     StartB #=> #~PrevHasStartedB,
     HasStartedB #/\ #~StartB #=> PrevHasStartedB,
     StartB #=> HasStartedB,
     (StartList == [] -> KGtOne #=> HasStartedB; true),
     constr_start(A,HasStartedB,StartList,HasStartedList,KGtOne).

% if B, then Y is the successor of X
entail_lfsr_succ(NB,B1,B2,X,Y) =>
    (var(X) ->
        get_attr(X,'$bool_vars') = $log(_,VectX)
    ;
        VectX = new_array(NB),
        dec_to_bin(X,1,NB,VectX)
    ),
    (var(Y) ->
        get_attr(Y,'$bool_vars') = $log(_,VectY)
    ;
        VectY = new_array(NB),
        dec_to_bin(Y,1,NB,VectY)
    ),
    entail_lfsr_succ_aux(B1,B2,VectX,VectY).

dec_to_bin(_Val,I,NB,_Vect), I > NB => true.
dec_to_bin(Val,I,NB,Vect) =>
   Vect[I] = Val mod 2,
   dec_to_bin(Val div 2, I+1, NB, Vect).

bin_to_dec(_Vect,I,Res0,Res), I == 0 => Res = Res0.
bin_to_dec(Vect,I,Res0,Res) =>
    bin_to_dec(Vect, I-1, 2*Res0+Vect[I], Res).

% B -> Y = succ(X)
entail_lfsr_succ_aux(B1,B2,{X1,X2},Y) =>   % taps = {1,2}
    Y = {Y1,Y2},
    entail_equiv(B1,B2,Y2,X1),
    entail_xor(B1,B2,Y1,X1,X2).
entail_lfsr_succ_aux(B1,B2,{X1,X2,X3},Y) =>   % taps = {2,3}
    Y = {Y1,Y2,Y3},
    entail_equiv(B1,B2,Y3,X2),
    entail_equiv(B1,B2,Y2,X1),
    entail_xor(B1,B2,Y1,X2,X3).
entail_lfsr_succ_aux(B1,B2,{X1,X2,X3,X4},Y) =>   % taps = {3,4}
    Y = {Y1,Y2,Y3,Y4},
    entail_equiv(B1,B2,Y4,X3),
    entail_equiv(B1,B2,Y3,X2),
    entail_equiv(B1,B2,Y2,X1),
    entail_xor(B1,B2,Y1,X3,X4).
entail_lfsr_succ_aux(B1,B2,{X1,X2,X3,X4,X5},Y) =>   % taps = {3,5}
    Y = {Y1,Y2,Y3,Y4,Y5},
    entail_equiv(B1,B2,Y5,X4),
    entail_equiv(B1,B2,Y4,X3),
    entail_equiv(B1,B2,Y3,X2),
    entail_equiv(B1,B2,Y2,X1),
    entail_xor(B1,B2,Y1,X3,X5).
entail_lfsr_succ_aux(B1,B2,{X1,X2,X3,X4,X5,X6},Y) =>   % taps = {5,6}
    Y = {Y1,Y2,Y3,Y4,Y5,Y6},
    entail_equiv(B1,B2,Y6,X5),
    entail_equiv(B1,B2,Y5,X4),
    entail_equiv(B1,B2,Y4,X3),
    entail_equiv(B1,B2,Y3,X2),
    entail_equiv(B1,B2,Y2,X1),
    entail_xor(B1,B2,Y1,X5,X6).
entail_lfsr_succ_aux(B1,B2,{X1,X2,X3,X4,X5,X6,X7},Y) =>   % taps = {6,7}
    Y = {Y1,Y2,Y3,Y4,Y5,Y6,Y7},
    entail_equiv(B1,B2,Y7,X6),
    entail_equiv(B1,B2,Y6,X5),
    entail_equiv(B1,B2,Y5,X4),
    entail_equiv(B1,B2,Y4,X3),
    entail_equiv(B1,B2,Y3,X2),
    entail_equiv(B1,B2,Y2,X1),
    entail_xor(B1,B2,Y1,X6,X7).
entail_lfsr_succ_aux(B1,B2,{X1,X2,X3,X4,X5,X6,X7,X8},Y) =>   % taps = {4,5,6,8}
    Y = {Y1,Y2,Y3,Y4,Y5,Y6,Y7,Y8},
    entail_equiv(B1,B2,Y8,X7),
    entail_equiv(B1,B2,Y7,X6),
    entail_equiv(B1,B2,Y6,X5),
    entail_equiv(B1,B2,Y5,X4),
    entail_equiv(B1,B2,Y4,X3),
    entail_equiv(B1,B2,Y3,X2),
    entail_equiv(B1,B2,Y2,X1),
    entail_xor(B1,B2,Y1,X4,X5,X6,X8).
entail_lfsr_succ_aux(B1,B2,{X1,X2,X3,X4,X5,X6,X7,X8,X9},Y) =>   % taps = {5,9}
    Y = {Y1,Y2,Y3,Y4,Y5,Y6,Y7,Y8,Y9},
    entail_equiv(B1,B2,Y9,X8),
    entail_equiv(B1,B2,Y8,X7),
    entail_equiv(B1,B2,Y7,X6),
    entail_equiv(B1,B2,Y6,X5),
    entail_equiv(B1,B2,Y5,X4),
    entail_equiv(B1,B2,Y4,X3),
    entail_equiv(B1,B2,Y3,X2),
    entail_equiv(B1,B2,Y2,X1),
    entail_xor(B1,B2,Y1,X5,X9).
entail_lfsr_succ_aux(B1,B2,{X1,X2,X3,X4,X5,X6,X7,X8,X9,X10},Y) =>   % taps = {7,10}
    Y = {Y1,Y2,Y3,Y4,Y5,Y6,Y7,Y8,Y9,Y10},
    entail_equiv(B1,B2,Y10,X9),
    entail_equiv(B1,B2,Y9,X8),
    entail_equiv(B1,B2,Y8,X7),
    entail_equiv(B1,B2,Y7,X6),
    entail_equiv(B1,B2,Y6,X5),
    entail_equiv(B1,B2,Y5,X4),
    entail_equiv(B1,B2,Y4,X3),
    entail_equiv(B1,B2,Y3,X2),
    entail_equiv(B1,B2,Y2,X1),
    entail_xor(B1,B2,Y1,X7,X10).
entail_lfsr_succ_aux(B1,B2,{X1,X2,X3,X4,X5,X6,X7,X8,X9,X10,X11},Y) =>   % taps = {9,11}
    Y = {Y1,Y2,Y3,Y4,Y5,Y6,Y7,Y8,Y9,Y10,Y11},
    entail_equiv(B1,B2,Y11,X10),
    entail_equiv(B1,B2,Y10,X9),
    entail_equiv(B1,B2,Y9,X8),
    entail_equiv(B1,B2,Y8,X7),
    entail_equiv(B1,B2,Y7,X6),
    entail_equiv(B1,B2,Y6,X5),
    entail_equiv(B1,B2,Y5,X4),
    entail_equiv(B1,B2,Y4,X3),
    entail_equiv(B1,B2,Y3,X2),
    entail_equiv(B1,B2,Y2,X1),
    entail_xor(B1,B2,Y1,X9,X11).
entail_lfsr_succ_aux(B1,B2,{X1,X2,X3,X4,X5,X6,X7,X8,X9,X10,X11,X12},Y) =>   % taps = {4,10,11,12}
    Y = {Y1,Y2,Y3,Y4,Y5,Y6,Y7,Y8,Y9,Y10,Y11,Y12},
    entail_equiv(B1,B2,Y12,X11),
    entail_equiv(B1,B2,Y11,X10),
    entail_equiv(B1,B2,Y10,X9),
    entail_equiv(B1,B2,Y9,X8),
    entail_equiv(B1,B2,Y8,X7),
    entail_equiv(B1,B2,Y7,X6),
    entail_equiv(B1,B2,Y6,X5),
    entail_equiv(B1,B2,Y5,X4),
    entail_equiv(B1,B2,Y4,X3),
    entail_equiv(B1,B2,Y3,X2),
    entail_equiv(B1,B2,Y2,X1),
    entail_xor(B1,B2,Y1,X4,X10,X11,X12).
entail_lfsr_succ_aux(B1,B2,{X1,X2,X3,X4,X5,X6,X7,X8,X9,X10,X11,X12,X13},Y) =>   % taps = {8,11,12,13}
    Y = {Y1,Y2,Y3,Y4,Y5,Y6,Y7,Y8,Y9,Y10,Y11,Y12,Y13},
    entail_equiv(B1,B2,Y13,X12),
    entail_equiv(B1,B2,Y12,X11),
    entail_equiv(B1,B2,Y11,X10),
    entail_equiv(B1,B2,Y10,X9),
    entail_equiv(B1,B2,Y9,X8),
    entail_equiv(B1,B2,Y8,X7),
    entail_equiv(B1,B2,Y7,X6),
    entail_equiv(B1,B2,Y6,X5),
    entail_equiv(B1,B2,Y5,X4),
    entail_equiv(B1,B2,Y4,X3),
    entail_equiv(B1,B2,Y3,X2),
    entail_equiv(B1,B2,Y2,X1),
    entail_xor(B1,B2,Y1,X8,X11,X12,X13).
entail_lfsr_succ_aux(B1,B2,{X1,X2,X3,X4,X5,X6,X7,X8,X9,X10,X11,X12,X13,X14},Y) =>   % taps = {2,12,13,14}
    Y = {Y1,Y2,Y3,Y4,Y5,Y6,Y7,Y8,Y9,Y10,Y11,Y12,Y13,Y14},
    entail_equiv(B1,B2,Y14,X13),
    entail_equiv(B1,B2,Y13,X12),
    entail_equiv(B1,B2,Y12,X11),
    entail_equiv(B1,B2,Y11,X10),
    entail_equiv(B1,B2,Y10,X9),
    entail_equiv(B1,B2,Y9,X8),
    entail_equiv(B1,B2,Y8,X7),
    entail_equiv(B1,B2,Y7,X6),
    entail_equiv(B1,B2,Y6,X5),
    entail_equiv(B1,B2,Y5,X4),
    entail_equiv(B1,B2,Y4,X3),
    entail_equiv(B1,B2,Y3,X2),
    entail_equiv(B1,B2,Y2,X1),
    entail_xor(B1,B2,Y1,X2,X12,X13,X14).

% B => X = Y
% i.e., (~B \/ ~X \/ Y) /\ (~B \/ X \/ ~Y)
entail_equiv(B1,B2,X,Y) =>
    #~B1 #\/ #~B2 #\/ #~X #\/ Y,
    #~B1 #\/ #~B2 #\/ X #\/ #~Y.

% B => Y = X1 ^ X2
entail_xor(B1,B2,Y,X1,X2) =>
    #~B1 #\/ #~B2 #\/ #~Y #\/ X1 #\/ X2,      % 1100 1
    #~B1 #\/ #~B2 #\/ Y #\/ #~X1 #\/ X2,      % 1010 1
    #~B1 #\/ #~B2 #\/ Y #\/ X1 #\/ #~X2,      % 1001 1
    #~B1 #\/ #~B2 #\/ #~Y #\/ #~X1 #\/ #~X2.  % 1111 1

% B => Y = X1 ^ X2 ^ X3 ^ X4
entail_xor(B1,B2,Y,X1,X2,X3,X4) =>
    #~B1 #\/ #~B2 #\/ #~Y #\/ X1 #\/ X2 #\/ X3 #\/ X4,
    #~B1 #\/ #~B2 #\/ Y #\/ #~X1 #\/ X2 #\/ X3 #\/ X4,
    #~B1 #\/ #~B2 #\/ Y #\/ X1 #\/ #~X2 #\/ X3 #\/ X4,
    #~B1 #\/ #~B2 #\/ #~Y #\/ #~X1 #\/ #~X2 #\/ X3 #\/ X4,
    #~B1 #\/ #~B2 #\/ Y #\/ X1 #\/ X2 #\/ #~X3 #\/ X4,
    #~B1 #\/ #~B2 #\/ #~Y #\/ #~X1 #\/ X2 #\/ #~X3 #\/ X4,
    #~B1 #\/ #~B2 #\/ #~Y #\/ X1 #\/ #~X2 #\/ #~X3 #\/ X4,
    #~B1 #\/ #~B2 #\/ Y #\/ #~X1 #\/ #~X2 #\/ #~X3 #\/ X4,
    #~B1 #\/ #~B2 #\/ Y #\/ X1 #\/ X2 #\/ X3 #\/ #~X4,
    #~B1 #\/ #~B2 #\/ #~Y #\/ #~X1 #\/ X2 #\/ X3 #\/ #~X4,
    #~B1 #\/ #~B2 #\/ #~Y #\/ X1 #\/ #~X2 #\/ X3 #\/ #~X4,
    #~B1 #\/ #~B2 #\/ Y #\/ #~X1 #\/ #~X2 #\/ X3 #\/ #~X4,
    #~B1 #\/ #~B2 #\/ #~Y #\/ X1 #\/ X2 #\/ #~X3 #\/ #~X4,
    #~B1 #\/ #~B2 #\/ Y #\/ #~X1 #\/ X2 #\/ #~X3 #\/ #~X4,
    #~B1 #\/ #~B2 #\/ Y #\/ X1 #\/ #~X2 #\/ #~X3 #\/ #~X4,
    #~B1 #\/ #~B2 #\/ #~Y #\/ #~X1 #\/ #~X2 #\/ #~X3 #\/ #~X4.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
global_cardinality(List,Pairs) =>
    (bp.check_pairs(Pairs) -> true; handle_exception($pairs_expected(Pairs),global_cardinality)),
    N = len(List),
    Cards = [Card : $(_-Card) in Pairs],
    (bp.dvar_or_int_list(Cards) ->
        LB = sum([fd_min(Card) : Card in Cards]),
        SumCards :: LB..N,
        SumCards #= sum(Cards),
        Keys = [Key : $(Key-_) in Pairs],        
        (LB == N, ground(Keys) ->
            List :: Keys
        ;
            true
        )
    ;
        true
    ),
    foreach($(Key-Card) in Pairs) 
         sum([B : E in List, B #<=> (E#=Key)]) #= Card
    end.

% neqs(Neqs) => neqs(Neqs).
neqs(Neqs) =>
    (array(Neqs) -> to_list(Neqs)=List; List=Neqs),    
    check_neqs_args(List,List1),
    foreach ('#\\='(X,Y) in List1)
        X #!= Y
    end.

% serialized(Starts,Durations) => serialized(Starts,Durations).
serialized(Starts,Durations) =>
    Len = Starts.length,
    Os = [1 : _ in 1..Len],
    cumulative(Starts,Durations,Os,1).

/************************************************************************* 
    regular(W,Q,S,M,Q0,Fs)

  W : A sentence (an IntVar array or list)
  Q : number of states
  S : input_max, inputs are from 1 to S
  M : transition matrix:  M[I,J] (I in 1..S, J in 1..Q) is a list of outgoing states for NFA (0 means an error).
  Q0: initial state
  Fs : accepting states
***************************************************************************/
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Model 'regular' as a single-agent path finding problem. Initially the agent
% is in state Q0. For each transition step, the agent consumes a token, and
% moves to the next state. At the end, the agent must be in one of the final states.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/*
regular(L, Q, S, M, Q0, Fs) =>
    regular_constr(L, Q, S, M, Q0, Fs, sat).
*/
regular(W, Q, S, M, Q0, Fs) =>
    check_regular_args(Q,S,M,Q0,Fs,Matrix,FsLst), % defined in "common_constr.pi"
    (array(W) -> WArr = W; WArr = to_array(W)),
    N = len(WArr),
    bp.domain(vars(W),1,S),
    N1 = N+1,
    A = new_array(N1,Q),                          % A[T,State] is true if the agent is in State at time T, A[1,Q0] = 1, T = 1..N+1
    B = new_array(N,S),                           % B[T,Input] is true if the agent observed Input at time T 
    transpose_trans_matrix(Matrix,TMatrix),       % defined in "common_constr.pi"
    preprocess_regular_constr_sat(WArr,Q,S,Matrix,TMatrix,Q0,FsLst,A,B,N),

    % initial and final states
    A[1,Q0] = 1,
    foreach (State in 1..Q, State !== Q0)
        A[1,State] = 0
    end,
    regular_exclude_unreachable(1,Q,FsLst,N1,A),  % set A[N1,State] = 0 if State is not in FsLst
    bp.domain(vars(A),0,1),
    bp.domain(vars(B),0,1),

    foreach (T in 2..N)
        sum([A[T,State] : State in 1..Q]) #= 1    % at each time, the agent stays in exactly one state
    end,
    sum([A[N1,State] : State in FsLst]) #= 1,     % at time N, the agent is in one of the final states

    % transition constraints
    foreach (State in 1..Q, Input in 1..S)
        Entry = Matrix[State,Input],
        if list(Entry) then
            foreach (T in 1..N, A[T,State] !== 0, B[T,Input] !== 0)
                sum([#~A[T,State], #~B[T,Input] | [A[T+1,ToState] : ToState in Entry]]) #>= 1
            end
        elseif Entry !== 0 then
            foreach (T in 1..N, A[T,State] !== 0, B[T,Input] !== 0)        
                #~A[T,State] #\/ #~B[T,Input] #\/ A[T+1,Entry]
            end
        else
            foreach (T in 1..N, A[T,State] !== 0, B[T,Input] !== 0)                
                 #~A[T,State] #\/ #~B[T,Input]   % no transition is possible from State on Input
            end
        end
    end,

    % channel constraints
    foreach (T in 1..N, Input in 1..S)
        (WArr[T] #= Input) #<=> B[T,Input]        % this entails sum([B[T,Input] : Input in 1..S]) #= 1
    end.

%% set A[T,State] to 0 if the agent cannot reach State at time T.
%% set B[T,Input] to 0 if the agent cannot consume Input at time T.
%
preprocess_regular_constr_sat(WArr,Q,S,Matrix,TMatrix,Q0,FsLst,A,B,N) =>
    regular_reason_backward_sat(WArr,Q,S,FsLst,len(FsLst),TMatrix,A,B,N+1,Done),
    regular_reason_forward_sat(WArr,Q,S,[Q0],1,Matrix,A,B,1,N,Done),
    (Done == 0 ->
        regular_sdist_heuristic_sat(Q,S,Matrix,TMatrix,Q0,FsLst,A,N)
    ;
        true
    ).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Shortest-distance heuristic: For a state, let D0 be the shortest distance to
% it from Q0. Then the state cannot reached in times 1,..., D0. Likewise, let
% Df be the shortest distance from the state to any final state. Then the state
% cannot be visited in times N-Df+2..N.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
regular_sdist_heuristic_sat(Q,S,Matrix,TMatrix,Q0,FsLst,A,N) =>
    SDFromQ0 = new_array(Q),                                  % SDFromQ0[I], the shortest distance to state I from Q0
    foreach (I in 1..Q)
        SDFromQ0[I] = N
    end,      
    SDFromQ0[Q0] := 0,
    MinHeap1 = new_min_heap([[0|Q0]]),
    fa_shortest_distance(MinHeap1,S,Matrix,SDFromQ0),         % defined in "common_constr.pi"
    %      
    SDFromF = new_array(Q),                                   % SDFromF[I], the shortest distance to I from any state in FsLst
    foreach (I in 1..Q)
        SDFromF[I] = N
    end,      
    foreach (F in FsLst)
        SDFromF[F] := 0
    end,
    MinHeap2 = new_min_heap([[0|FState] : FState in FsLst]),
    fa_shortest_distance(MinHeap2,S,TMatrix,SDFromF),
    %
    foreach (State in 1..Q)
        foreach (T in 2..SDFromQ0[State])
            A[T,State] = 0
        end,
        foreach (T in (N-SDFromF[State]+2)..N)
            A[T,State] = 0
        end
    end.
    %

% Dijkstra's algorithm
fa_shortest_distance(MinHeap,_S,_Matrix,_DistVect), heap_is_empty(MinHeap) => true.
fa_shortest_distance(MinHeap,S,Matrix,DistVect) =>
    [Dist|State] = heap_pop(MinHeap),
    Dist1 = Dist+1,
    foreach (Input in 1..S)
        Entry = Matrix[State,Input],
        if list(Entry) then
            foreach (NextState in Entry)
                if (DistVect[NextState] =< Dist1) then
                    true
                else
                    heap_push(MinHeap,[Dist1|NextState]),
                    DistVect[NextState] := Dist1
                end
            end
       elseif Entry !== 0 then
            if (DistVect[Entry] =< Dist1) then
                true
            else
                heap_push(MinHeap,[Dist1|Entry]),
                DistVect[Entry] := Dist1
            end
        end
    end,
    fa_shortest_distance(MinHeap,S,Matrix,DistVect).

%% When expanding forward, the first frontier is [Q0]. After expanding Front, Font1 becomes the new frontier.
%% Assume the agent is in a state in Front at time T. Then, it will be in a state in Front1 and consume a symbol
%% in Syms at time T+1.
regular_reason_forward_sat(WArr,Q,S,Front,FrontSize,Matrix,A,B,T,N,Done) =>
    (T == N ->
        true
    ; FrontSize == Q ->
        true
    ; FrontSize >= 512 ->
        Done = 0
    ;
        T1 = T+1,
        Wi = WArr[T],
        bp.fd_domain(Wi,Inputs),        
        regular_expand(Inputs,Matrix,Front,Front1,Syms),      % defined in "common_constr.pi"
        regular_exclude_unreachable(1,Q,Front1,T1,A),
        regular_exclude_unreachable(1,S,Syms,T,B),
        regular_reason_forward_sat(WArr,Q,S,Front1,len(Front1),Matrix,A,B,T1,N,Done)
    ).

%% When expanding backward, the first frontier is FsLst at time N
regular_reason_backward_sat(WArr,Q,S,Front,FrontSize,TMatrix,A,B,T,Done) =>
    (T == 2 ->
        true
    ; FrontSize == Q ->
        true
    ; FrontSize >= 512 ->
        Done = 0
    ;
        T1 is T-1,
        Wi = WArr[T1],
        bp.fd_domain(Wi,Inputs),        
        regular_expand(Inputs,TMatrix,Front,Front1,Syms),    
        regular_exclude_unreachable(1,Q,Front1,T1,A),
        regular_exclude_unreachable(1,S,Syms,T1,B),
        regular_reason_backward_sat(WArr,Q,S,Front1,len(Front1),TMatrix,A,B,T1,Done)
    ).

% set Arr[T,Val] = 0 for each Val in 1..Max that is not included in Dom
regular_exclude_unreachable(Val,Max,_Dom,_T,_Arr), Val > Max => true.
regular_exclude_unreachable(Val,Max,[Val|Dom],T,Arr) =>
    regular_exclude_unreachable(Val+1,Max,Dom,T,Arr).
regular_exclude_unreachable(Val,Max,[E|Dom],T,Arr), Val > E =>
    regular_exclude_unreachable(Val,Max,Dom,T,Arr).
regular_exclude_unreachable(Val,Max,Dom,T,Arr) =>
    Arr[T,Val] = 0,
    regular_exclude_unreachable(Val+1,Max,Dom,T,Arr).


%%
%% lex_le(L1,L2): collection L1 is lexicographically less than or equal to L2
%%
lex_le(L1,L2),list(L1),list(L2) =>
    check_args_lex(L1,L2,L11,L22),
    lex_le_aux(L11,L22).
lex_le(L1,L2),array(L1),array(L2) =>
    check_args_lex(to_list(L1),to_list(L2),L11,L22),
    lex_le_aux(L11,L22).
lex_le(L1,L2) =>
    throw($invalid(lex_le(L1,L2))).

%%
%% lex_lt(L1,L2): collection L1 is lexicographically less than L2
%%
lex_lt(L1,L2),list(L1),list(L2) =>
    check_args_lex(L1,L2,L11,L22),
    lex_lt_aux(L11,L22).
lex_lt(L1,L2),array(L1),array(L2) =>
    check_args_lex(to_list(L1),to_list(L2),L11,L22),
    lex_lt_aux(L11,L22).
lex_lt(L1,L2) =>
    throw($invalid(lex_lt(L1,L2))).

check_args_lex(L1,L2,L11,L22) =>
    (bp.dvar_or_int_list(L1) -> true; handle_exception($dvar_list_expected(L1),lex)),
    (bp.dvar_or_int_list(L2) -> true; handle_exception($dvar_list_expected(L2),lex)),
    N1 = length(L1),
    N2 = length(L2),
    (N1==N2 ->
        L11 = L1, L22 = L2
    ;N1<N2 ->
        Min = min([fd_min(V) : V in L2]),
        Min1 = Min-1,
        L1Pad = [Min1 : _ in 1..N2-N1],
        L11 = L1++L1Pad, L22=L2
    ;
        Min = min([fd_min(V) : V in L1]),
        Min1 = Min-1,
        L2Pad = [Min1 : _ in 1..N1-N2],
        L11 = L1, L22 = L2++L2Pad
    ).

lex_le_aux([],_) => true.
lex_le_aux([X],[Y|_]) => X #=< Y.
lex_le_aux([X1,X2],[Y1,Y2|_]) => (X1 #< Y1) #\/ (X1 #= Y1 #/\ (X2 #=< Y2)).
lex_le_aux(L1,L2) =>
    N1 = length(L1),
    N2 = length(L2),
    (N1 > N2 ->
        L11 = new_list(N2),
        once(append(L11,_,L1)),
        lex_lt_aux(L11,L2)
    ;        
        N = N1,
        A1 = to_array(L1),
        A2 = to_array(L2),
        ReifLexLE = new_array(N),
        ReifLexLE :: 0..1,
        ReifLexLE[N] #<=> (A1[N] #=< A2[N]),
        foreach(I in 2..N-1)
            ReifLexLE[I] #<=> (A1[I] #< A2[I] #\/ ((A1[I] #= A2[I]) #/\ ReifLexLE[I+1]))
            end,
        A1[1] #< A2[1] #\/ ((A1[1] #= A2[1]) #/\ ReifLexLE[2])
    ).

lex_lt_aux([],_) => true.
lex_lt_aux([X],[Y]) => X #< Y.
lex_lt_aux([X],[Y|_]) => X #=< Y.
lex_lt_aux([X1,X2],[Y1,Y2]) => (X1 #< Y1) #\/ (X1 #= Y1 #/\ (X2 #< Y2)).
lex_lt_aux([X1,X2],[Y1,Y2|_]) => (X1 #< Y1) #\/ (X1 #= Y1 #/\ (X2 #=< Y2)).
lex_lt_aux(L1,L2) =>
    N1 = length(L1),
    N2 = length(L2),
    (N1 >= N2 ->
        N = N2,
        A1 = to_array(L1),
        A2 = to_array(L2),
        ReifLexLE = new_array(N),
        ReifLexLE :: 0..1,
        ReifLexLE[N] #<=> (A1[N] #< A2[N]),
        foreach(I in 2..N-1)
            ReifLexLE[I] #<=> (A1[I] #< A2[I] #\/ ((A1[I] #= A2[I]) #/\ ReifLexLE[I+1]))
        end,
        A1[1] #< A2[1] #\/ ((A1[1] #= A2[1]) #/\ ReifLexLE[2])
    ;
        L22 = new_list(N1),
        once(append(L22,_,L2)),
        lex_le_aux(L1,L22)
    ).

%%
nvalue(N,L) => bp.'$nvalue'(N,L).

%% The following constraints are proposed and implemented by Hakan Kjellerstrand
matrix_element(M,I,J,MIJ) =>
    check_matrix(M,NRows,NCols),
    matrix_element(M,NRows,NCols,I,J,MIJ,sat).

%
% Scalar product of the list A and X
%
scalar_product(A, X, Product) => 
    scalar_product(A, X, '#=', Product).

%
% scalar product of List A and X, with one of the relations: 
% 
%   #=, #<, #>, #<=, #>=, #!=
%
scalar_product(A, X, '#=', Product) => 
   check_scalars(A,X),
   sum([A[I]*X[I] : I in 1..A.length]) #= Product.

scalar_product(A, X, '#!=', Product) => 
   check_scalars(A,X),
   sum([A[I]*X[I] : I in 1..A.length]) #!= Product.

scalar_product(A, X, '#>=', Product) => 
   check_scalars(A,X),
   sum([A[I]*X[I] : I in 1..A.length]) #>= Product.

scalar_product(A, X, '#>', Product) => 
   check_scalars(A,X),
   sum([A[I]*X[I] : I in 1..A.length]) #> Product.

scalar_product(A, X, '#<=', Product) => 
   check_scalars(A,X),
    scalar_product(A, X, '#=<', Product).

scalar_product(A, X, '#=<', Product) => 
   check_scalars(A,X),
   sum([A[I]*X[I] : I in 1..A.length]) #=< Product.

scalar_product(A, X, '#<', Product) => 
   check_scalars(A,X),
   sum([A[I]*X[I] : I in 1..A.length]) #< Product.

%
% exactly(?N,?X,?V)
%
% Requires that exactly N variables in X takes the value V.
%
exactly(N, X, V) =>
  count(V,X,#=,N).

%
% at_most(?N,?X,?V)
%
% Requires that atmost N variables in X takes the value V.
%
at_most(N,X,V) => 
  count(V,X,#=<,N).

%
% at_least(?N,?X,?V)
%
% Requires that atleast N variables in X takes the value V.
%
at_least(N,X,V) => 
  count(V,X,#>=,N).

%
% Ensure that List is increasing
%
increasing(FDVars),array(FDVars) =>
   foreach(I in 2..length(FDVars)) FDVars[I-1] #=< FDVars[I] end.
increasing(FDVars),list(FDVars) =>
   increasing_list(FDVars).
increasing(FDVars) =>
   handle_exception($list_or_array_expected(FDVars),increasing).

increasing_list([]) => true.
increasing_list([_]) => true.
increasing_list([X|T@[Y|_]]) => 
    X #=< Y,
    increasing_list(T).

increasing_strict(FDVars),array(FDVars) =>
   foreach(I in 2..length(FDVars)) FDVars[I-1] #< FDVars[I] end.
increasing_strict(FDVars),list(FDVars) =>
   increasing_strict_list(FDVars).
increasing_strict(FDVars) =>
   handle_exception($list_or_array_expected(FDVars),increasing_strict).

increasing_strict_list([]) => true.
increasing_strict_list([_]) => true.
increasing_strict_list([X|T@[Y|_]]) => 
    X #< Y,
    increasing_strict_list(T).

%
% Ensure that FDVars is decreasing
%
decreasing(FDVars),array(FDVars) =>
   foreach(I in 2..length(FDVars)) FDVars[I-1] #>= FDVars[I] end.
decreasing(FDVars),list(FDVars) =>
   decreasing_list(FDVars).
decreasing(FDVars) =>
   handle_exception($list_or_array_expected(FDVars),decreasing).

decreasing_list([]) => true.
decreasing_list([_]) => true.
decreasing_list([X|T@[Y|_]]) => 
    X #>= Y,
    decreasing_list(T).

decreasing_strict(FDVars),array(FDVars) =>
   foreach(I in 2..length(FDVars)) FDVars[I-1] #> FDVars[I] end.
decreasing_strict(FDVars),list(FDVars) =>
   decreasing_strict_list(FDVars).
decreasing_strict(FDVars) =>
   handle_exception($list_or_array_expected(FDVars),decreasing_strict).

decreasing_strict_list([]) => true.
decreasing_strict_list([_]) => true.
decreasing_strict_list([X|T@[Y|_]]) => 
    X #> Y,
    decreasing_strict_list(T).
