Picat is a general-purpose language that incorporates features from logic programming, functional programming, constraint programming,  and scripting languages. The letters in the name summarize Picat's features:

\begin{itemize}
\item \textbf{P}attern-matching: A \emph{predicate} defines a relation, and can have zero, one, or multiple answers. A \emph{function} is a special kind of a predicate that always succeeds with \emph{one} answer. Picat is a rule-based language. Predicates and functions are defined with pattern-matching rules. Since version 3.0, Picat also supports Prolog-style Horn clauses and Definite Clause Grammar (DCG) rules.

\item \textbf{I}ntuitive: Picat provides assignment and loop statements for programming everyday things. An assignable variable mimics multiple logic variables, each of which holds a value at a different stage of computation. Assignments are useful for computing aggregates and are used with the {\tt foreach} loop for implementing list and array comprehensions.

\item \textbf{C}onstraints: Picat supports constraint programming.  Given a set of variables, each of which has a domain of possible values, and a set of constraints that limit the acceptable set of assignments of values to variables, the goal is to find an assignment of values to the variables that satisfies all of the constraints. Picat provides four solver modules: {\tt cp}, {\tt sat}, {\tt smt}, and {\tt mip}. These four modules follow the same interface, which allows for seamless switching from one solver to another.

\item \textbf{A}ctors: Actors are event-driven calls.  Picat provides \emph{action rules} for describing event-driven behaviors of actors. Events are posted through channels. An actor can be attached to a channel in order to watch and to process its events. All the propagators used in {\tt cp} are implemented as actors.
% Picat treats threads as channels, and allows the use of action rules\index{action rule} to program concurrent threads\index{thread}.

\item \textbf{T}abling: Tabling can be used to store the results of certain calculations in memory, allowing the program to do a quick table lookup instead of repeatedly calculating a value. As computer memory grows, tabling is becoming increasingly important for offering dynamic programming solutions for many problems. The \texttt{planner} module, which is implemented by the use of tabling, has been shown to be an efficient tool for solving planning problems.

\end{itemize}

The support of unification, non-determinism, tabling, and constraints makes Picat more suitable than functional and scripting languages for symbolic computations. Picat is more convenient than Prolog for scripting and modeling. With arrays, loops, and comprehensions, it is not rare to find problems for which Picat requires an order of magnitude fewer lines of code to describe than Prolog. Picat is more scalable than Prolog. The use of pattern-matching rather than unification facilitates indexing of rules. Picat is not as powerful as Prolog for metaprogramming and it's impossible to write a meta-interpreter for Picat in Picat itself. Nevertheless, this weakness can be remedied with library modules for implementing domain-specific languages.

The Picat implementation is based on the B-Prolog engine. The current implementation is ready for many kinds of applications. It also serves as a foundation for new additions. The project is open, and you are welcome to join as a developer, a sponsor, a user, or a reviewer. Please contact \url{picat@picat-lang.org} and join the news group \url{https://groups.google.com/g/picat-lang}.


